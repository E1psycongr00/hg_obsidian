---
tags:
  - 디자인패턴
  - GoF
  - 추상팩토리
  - 안티패턴
  - 리팩토링
aliases:
  - Abstract Factory Antipatterns
  - 추상 팩토리 오용
created: 2025-06-08
title: 🔍 추상 팩토리 패턴 안티패턴 및 오용 사례
note-type: REVIEW
review-type: 패턴 비판적 분석
analysis-depth: 심층
practical-focus: 높음
---

## 1. 개요: 패턴을 사용하지 않아야 할 때

추상 팩토리 패턴은 '관련된 객체들의 집합(제품군)'을 일관성 있게 생성하는 강력한 도구이지만, 모든 상황에 맞는 해결책은 아니다. 잘못 사용하면 오히려 코드의 복잡성을 높이고 유지보수를 어렵게 만드는 '안티패턴'이 될 수 있다.

이 문서는 추상 팩토리 패턴이 오용될 수 있는 대표적인 사례들을 분석하고, 더 나은 대안을 모색하여 패턴을 올바르게 사용하는 기준을 제시하는 것을 목표로 한다.

## 2. 주요 안티패턴 및 오용 사례

### 사례 1: 불필요한 복잡성 증가 (Over-Engineering)

#### 1.1. 너무 작은 제품군
- **상황**: 생성해야 할 제품군이 한두 개의 객체로 구성되거나, 제품 간 관련성이 거의 없는 경우.
- **문제점**: 불필요하게 많은 인터페이스와 클래스가 도입되어 코드 복잡성이 증가한다. 단순한 객체 생성을 위해 과도한 추상화 계층을 만드는 것은 [[05. Reference Notes/Web/📚 YAGNI (You Aren't Gonna Need It)|YAGNI(You Aren't Gonna Need It)]] 원칙에 위배된다.
- **대안**:
    - **단순 팩토리 (Simple Factory)**: 생성 로직을 하나의 클래스나 메서드에 위임.
    - **팩토리 메서드 패턴**: 단일 객체 생성을 서브클래스에 위임.

#### 1.2. 관련성 없는 제품의 집합
- **상황**: 하나의 팩토리가 서로 관련 없거나 함께 사용될 필요가 없는 객체들을 생성하는 경우. (예: `createDatabaseConnection()`과 `createLogger()`가 같은 팩토리에 있는 경우)
- **문제점**: 패턴의 핵심 목적인 '제품군 일관성 보장'이라는 이점을 얻지 못하며, 관련 없는 변경에 서로 영향을 주게 된다.
- **대안**: 각기 다른 책임을 가진 별도의 팩토리로 분리.

### 사례 2: 변경에 취약한 설계 (OCP 위반)

- **상황**: 기존 제품군에 새로운 종류의 제품을 추가해야 할 때. (예: `Button`, `TextField` 외에 `Checkbox` 추가)
- **문제점**: `AbstractFactory` 인터페이스에 `createCheckbox()` 메서드를 추가해야 하며, 이 인터페이스를 구현하는 모든 구체 팩토리(`WindowsFactory`, `MacFactory` 등)를 수정해야 한다. 이는 **개방-폐쇄 원칙(OCP)**을 위반한다.
- **핵심**: 추상 팩토리 패턴은 **새로운 제품군(Variant) 추가에는 강하지만, 새로운 제품 종류(Type) 추가에는 취약하다.**
- **대안**:
    -   요구사항을 재분석하여 빌더 패턴 등 다른 패턴이 더 적합한지 검토.
    -   플러그인 아키텍처나 리플렉션을 사용하여 동적으로 제품을 등록하고 생성하는 방식 고려.

### 사례 3: 거대한 팩토리 인터페이스 (ISP 위반)

- **상황**: `AbstractFactory` 인터페이스가 너무 많은 `create` 메서드를 가지게 되고, 특정 구체 팩토리는 그중 일부만 생성할 수 있는 경우. (예: `MobileFactory`는 `createMenuBar()`를 지원하지 않음)
- **문제점**: `MobileFactory`는 `createMenuBar()`를 불필요하게 구현해야 하며, 보통 예외를 던지거나 `null`을 반환하게 된다. 이는 **인터페이스 분리 원칙(ISP)** 위반이다.
- **대안**:
    -   역할과 책임에 따라 여러 개의 작은 `AbstractFactory` 인터페이스로 분리.
    -   `create` 메서드에 `null`을 반환하는 대신, 해당 제품 생성을 지원하는지 확인하는 `canCreate`와 같은 메서드를 제공.

## 3. 결론: 언제 추상 팩토리를 재고해야 하는가?

다음과 같은 질문에 "예"라고 답할 수 있다면, 추상 팩토리 패턴 대신 다른 접근법을 고려하는 것이 좋다.

| 질문                                                     | 재고 이유                    | 대안                                            |
| -------------------------------------------------------- | ---------------------------- | ----------------------------------------------- |
| 생성할 객체가 하나이거나, 서로 관련이 없는가?            | 과도한 엔지니어링            | 단순 팩토리, 팩토리 메서드                      |
| 앞으로 새로운 '제품 종류'가 자주 추가될 가능성이 높은가? | OCP 위반                     | 빌더 패턴, 프로토타입 패턴, 컴포지트 패턴       |
| 모든 팩토리가 모든 제품을 생성하지는 않는가?             | ISP 위반                     | 인터페이스 분리, 더 작은 팩토리들로 재구성      |
| DI 컨테이너를 사용하고 있는가?                           | 프레임워크가 역할을 대신함   | 프레임워크의 DI 기능 활용                       |

## 관련 자료

- [[02. MOC/🏛️ 추상 팩토리 패턴.md|🏛️ 추상 팩토리 패턴 MOC]]
- [[03. Permanent Notes/🔍 생성 패턴 비교 분석 - 추상 팩토리 vs 팩토리 메서드.md|🔍 패턴 비교 분석]]
- [[02. MOC/🏛️ SOLID 원칙|🏛️ SOLID 원칙]] 