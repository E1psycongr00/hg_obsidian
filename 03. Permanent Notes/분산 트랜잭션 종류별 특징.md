---
tags:
  - MSA
  - Transaction
aliases: 
created: 2024-12-04
title: 분산 트랜잭션 종류별 특징
note-type: COMMON
completed: true
---

## 내용(Content)

### 분산 트랜잭션

>[!summary]
>여러 독립적인 시스템, DB, 또는 서비스들을 하나의 트랜잭션처럼 쓰는 것

다른 API나 독립적인 모듈, 독립적인 DB, 서비스들의 작업을 하나의 트랜잭션처럼 묶어버리는 것을 의미한다. 그러나 완전히 독립적으로 구성되어 있기 때문에 [[DB 트랜잭션]]처럼 완전한 ACID를 보장할 수 없다.


### 2PC

>[!summary]
>2단계 커밋 또는 2 Phase Commit으로 불린다. 코디네이터라는 트랜잭션 관리자가 있으며, 각 트랜잭션들을 묶어서 하나의 트랜잭션처럼 관리한다.


#### Prepare Phase

코디네이터가 각 트랜잭션이 준비됬는지 확인하는 단계이다.


#### Commit Phase

모든 트랜잭션이 커밋이 완료되고, 모두 성공한다면 Commit을 유지한다. 만약 여러 트랜잭션 중 하나라도 문제가 생기면 모두 ROLL BACK을 지시한다.

#### 장점

- 분산 시스템에서 원자성을 잘 보장한다.

####  단점

- 모든 트랜잭션의 요청을 처리할 떄까지 모든 DB들이 LOCK이 될 수 있다.
- 코디네이터가 중앙을 관리하는 구조이지만 이건 서비스 간에 강결합을 생성하므로, 모듈화 취지에 어긋난다.
- NoSQL은 2PC 패턴 방식을 지원하지 않는다.
- 코디네이터가 문제가 생기면 서비스 모두가 마비된다.
- 모든 트랜잭션 참여자가 커밋 또는 롤백이 되야 할 때까지 기다리는 방식이기 때문에 네트워크 지연이나 트랜잭션 서비스가 지연이 발생하는 경우 성능 저하가 발생할 수 있다.

### SAGA 패턴

>[!summary]
>트랜잭션 서비스 참여자들 간에 이벤트를 통해 서로 소통하며 트랜잭션을 처리한다.

SAGA는 코디네이터와 같은 관리자 없이 각 서비스들끼리 이벤트 기반으로 소통하며, 트랜잭션을 순차적으로 처리한다. 이 때 중간에 트랜잭션에 문제가 생기면, 트랜잭션 롤백을 위해 **보상 트랜잭션**을 실행한다.

Saga는 크게 2가지 방식으로 나뉜다.

-  Choreographed Saga(코어리그래프드 사가)
-  Orchestrated Saga(오케스트레이트 사이가)


>[!tip] Tip: 보상 트랜잭션
>보상 트랜잭션은 직접 트랜잭션을 롤백하는 것이 아닌, 롤백한 것처럼 상태를 되돌려 놓는 것을 의미한다. 그 이유는 SAGA는 한 트랜잭션이 끝나면 COMMIT을 하기 때문에 다른 트랜잭션에서 실패 시 이전 트랜잭션의 상태를 강제로 조정해서 COMMIT한다.

#### Choreographed Saga

**Choreographed**는 주로 춤이나 안무처럼 정교하게 계획되고 조화롭게 구성된 것을 의미하며, 비유적으로는 어떤 일이 세심하게 설계되거나 연출된 상황을 나타낼 때도 사용된다. **Choreographed Saga**는 마치 정교하게 짜여진 분산 트랜잭션 패턴처럼, 각 서비스 간의 이벤트가 긴밀하게 연결된 구조를 가지고 있다.

![[Pasted image 20241204204500.png|[\[Database\] 분산 트랜잭션과 2PC, SAGA 패턴](https://bezzang2.tistory.com/233)]]

이 패턴의 장점은 중앙 제어가 필요 없고 마치 서비스 모듈(노드) 간 연결을 event(edge)를 통해 수행하면서 마치 그래프와 같이 사용된다. 구현이 매우 간단하고 직관적이다. 그러나 순환 종속성 문제(cycle)이 발생할 가능성이 있고, 규모가 커지면 관리가 쉽지 않다. 

#### Orchestrated Saga

오케스트라를 보면 수 많은 악기를 다루는 사람들을 지휘자가 지휘한다. Orchestrated Saga는 saga 클래스를 생성해서 saga가 여러 이벤트를 모두 관리하는 형태이다. 전략, 상태와 같은 패턴을 써서 이벤트를 관리하고 소통할 수 있다. 

![[Pasted image 20241204220320.png|[\[Database\] 분산 트랜잭션과 2PC, SAGA 패턴](https://bezzang2.tistory.com/233)]]

중앙의 컨트롤러가 전체 흐름과 보상 작업 제어를 하는데 위 그림을 바탕으로 예시를 들어보자.

1. Order 서비스가 요청을 받으면 Order Saga를 생성한다.
2. Saga 오케스트레이터가 PENDING 주문을 생성한다.
3. Customer Service에 신용 예약 명령을 내린다.
4. 결과를 나타내는 메시지를 사가 오케스트레이터에게 보낸다.
5. 사가 오케스트레이터는 해당 결과에 따라 주문을 승인하거나 거절한다.

이렇게 오케스트라 방식은 특정 서비스 모듈의 SAGA가 주체가 되어 직접 이벤트를 모아서 제어하기 때문에 어느 정도 중앙 통제가 가능해진다. 그렇기에 이벤트를 한눈에 보기 쉬워지는 장점이 있다. 그러나 Saga라는 객체를 생성해야 하고, 의존성이 커지는 문제점도 있다.


## 질문 & 확장

(없음)

## 출처(링크)

- [\[Database\] 분산 트랜잭션과 2PC, SAGA 패턴](https://bezzang2.tistory.com/233)
- [\[MSA\] 개인 프로젝트 Monolithic to MSA 전환기 - (8) 분산 트랜잭션 환경에서 트랜잭션 처리하기(feat. 2PC, Saga 패턴, Choreographed Saga) — 성장하는 성하 Blog](https://ksh-coding.tistory.com/143#3.%20%08Saga%20%ED%8C%A8%ED%84%B4-1)
- [\[MSA\] SAGA 패턴이란 무엇인가 ?](https://digitalbourgeois.tistory.com/193)


## 연결 노트

- [[DB 트랜잭션]]








