---
tags:
  - 완성
  - 객체지향
  - 디자인패턴
  - 유한오토마타
aliases:
  - 유한 상태 머신
  - FSM
  - State Machine
  - 유한 상태 오토마타
title: Finite State Machine
created: 2024-06-19T00:00:00.000Z
---
작성 날짜: 2024-06-19
작성 시간: 16:21


----
## 내용(Content)


### 유한 상태 기계(Finite State Machine)

>[!summary]
>유한 상태 기계는 시스템의 상태와 그 상태 간의 전이를 모델링하는 강력한 도구다.

유한 상태 기계(Finite State Machine, FSM)는 시스템의 상태를 명확하게 정의하고 상태 간의 전이를 모델링하는 데 있어 매우 강력한 개념적 도구다. FSM은 수학적 모델로 시스템이 특정 상태에서 시작해 입력에 따라 상태가 전이되는 과정을 구조화하는 방식으로 작동한다. 이는 다양한 형태의 소프트웨어 엔지니어링 문제를 해결하는 데 있어 핵심적인 역할을 하는 데, 이번 글에서는 FSM의 이론적 배경과 함께 실제 적용 사례를 통해 개발자가 어떻게 FSM을 활용할 수 있는지 살펴보고자 한다.

### FSM의 기본 개념

FSM은 여러 개의 상태(states)와 입력에 따라 상태가 전이(transition)하는 구조로 이루어져 있다. 상태는 시스템의 현재 조건을 나타내며, 전이는 특정 입력(input)에 의해 한 상태에서 다른 상태로의 변화를 설명 가능하다. 이러한 구조는 복잡한 시스템을 단순하고 명확하게 모델링할 수 있는 특징을 가지고 있다. 상태와 전이의 관계를 도시와 도로로 비유할 수 있는데, 각 상태가 도시라면 전이는 그 도시들을 연결하는 도로와 같다.

FSM은 크게 두 가지 종류로 나눌 수 있다:

- **Deterministic Finite Automaton (DFA)**: DFA에서는 특정 입력에 대해 하나의 상태로만 전이할 수 있다. 즉, 모든 입력에 대해 다음 상태가 명확하게 정의된다는 특징을 가진다. 예를 들어, 자동판매기에서 특정 금액을 넣었을 때 정확히 하나의 제품이 나오도록 동작하는 것이 DFA의 예시 중 하나라 할 수 있다. 이러한 확실성은 상태를 추적하고 예측 가능하게 만들기에 매우 유용하다.
- **Nondeterministic Finite Automaton (NFA)**: NFA는 특정 입력에 대해 여러 개의 가능한 다음 상태로 이동할 수 있는 유연성을 가지고 있다. 즉, 같은 입력에 대해 여러 상태로의 전이가 가능하기 때문에 시스템이 보다 복잡한 동작을 수행할 수 있다. 예를 들어, 미로 탐색에서 여러 갈림길이 있을 때 동시에 여러 경로를 시도해 볼 수 있는 것이 NFA의 예시라 할 수 있다. 이는 문제의 해결 방법을 병렬적으로 탐색할 수 있는 가능성을 제공하지. 이러한 병렬적 탐색의 유연성 덕분에 NFA는 복잡한 문제의 모든 가능한 해결 경로를 동시에 고려할 수 있어, 최종적으로 더 효율적인 해결책을 찾을 수 있게 된다.

### DFA와 NFA의 차이

| 특징    | DFA (Deterministic Finite Automaton) | NFA (Nondeterministic Finite Automaton) |
| ----- | ------------------------------------ | --------------------------------------- |
| 상태 전이 | 각 입력에 대해 하나의 상태로 전이                  | 각 입력에 대해 여러 상태로 전이 가능                   |
| 복잡성   | 구현이 단순하고 명확함                         | 구현이 더 유연하지만 복잡할 수 있음                    |
| 상태 수  | 일반적으로 더 많은 상태를 필요로 함                 | 상태 수가 상대적으로 적을 수 있음                     |
| 실행 속도 | 보통 빠름                                | 느릴 수 있음 (동시에 여러 경로 탐색)                  |
| 직관성   | 전이가 명확하게 정의됨                         | 전이가 모호할 수 있음                            |


### FSM의 구성 요소

FSM은 다음과 같은 구성 요소로 이루어져 있다:

- **상태(State)**: 시스템이 가질 수 있는 모든 가능한 조건들. 예를 들어, 문을 제어하는 시스템에서는 "열림(OPEN)"과 "닫힘(CLOSED)"이라는 두 가지 상태가 있을 수 있다.
- **입력(Input)**: 상태를 변화시키는 외부 이벤트나 신호. 예를 들어, 문을 여는 버튼 클릭이 입력이 될 수 있다.
- **초기 상태(Initial State)**: 시스템이 시작될 때의 상태. 모든 FSM은 항상 하나의 초기 상태에서 시작한다.
- **종료 상태(Final State)**: 종료 상태는 더 이상 전이가 없는 상태로, 시스템의 끝을 나타내. 모든 FSM이 종료 상태를 필요로 하지는 않는다.
- **전이(Transition)**: 한 상태에서 다른 상태로의 이동을 의미하며, 이는 일반적으로 특정 조건(입력)에 따라 발생한다.

>[!help] Help: 5-튜플
> FSM은 수학적으로 다음의 5-튜플을 정의할 수 있다.
> 
>- $Q$ : 모든 상태의 집합.
>- $\sum$ : 입력 기호의 집합 (알파벳).
>- $\delta$: 전이 함수 , 현재 상태와 입력을 받아 다음 상태를 반환.
>- $s_0$: 초기 상태로, Q의 원소
>- $F$: 종료 상태들의 집합으로 Q의 원소
>
>위의 정의에서  함수는 입력과 현재 상태의 조합으로 다음 상태를 결정하는 역할을 한다. 이를 통해 시스템이 어떻게 동작하는지 수학적으로 명확하게 표현할 수 있다.

>[!help] Help: 사용자 인증 시스템의 FSM 5-튜플 정의
>
>- $Q = {LOGGED\_OUT, LOGGING\_IN, LOGGED\_IN, LOCKED}$
>- $\Sigma = {\text{자격 증명 제출, 로그인 성공, 로그인 실패, 로그아웃}}$
>- $\delta$: 전이 테이블 참조
>- $s_0 = LOGGED\_OUT$
>- $F = \emptyset$

### 예제: 사용자 인증 시스템

FSM의 개념을 좀 더 복잡하게 이해하기 위해 사용자 인증 시스템을 예로 들어보자.

- **상태**: 사용자 인증 시스템은 다음과 같은 상태를 가질 수 있다:
	- **로그아웃(LOGGED\_OUT)**: 사용자가 인증되지 않은 상태.
	- **로그인 시도(LOGGING\_IN)**: 사용자가 자격 증명을 제출하는 상태.
	- **로그인 성공(LOGGED\_IN)**: 사용자가 성공적으로 인증된 상태.
	- **잠금(LOCKED)**: 잘못된 비밀번호를 여러 번 입력하여 계정이 잠긴 상태.

- **입력**: 상태 전이를 유발하는 입력은 다음과 같아:
	- **자격 증명 제출**: 사용자가 아이디와 비밀번호를 제출하는 행위.
	- **로그인 성공**: 올바른 자격 증명을 제출했을 때.
	- **로그인 실패**: 잘못된 자격 증명을 제출했을 때.
	- **로그아웃**: 사용자가 시스템에서 로그아웃하는 행위.

이러한 상태와 입력을 FSM으로 모델링하면 다음과 같은 전이 테이블을 만들 수 있다:

| 현재 상태       | 입력          | 다음 상태       |
| ----------- | ----------- | ----------- |
| LOGGED\_OUT | 자격 증명 제출    | LOGGING\_IN |
| LOGGING\_IN | 로그인 성공      | LOGGED\_IN  |
| LOGGING\_IN | 로그인 실패      | LOGGED\_OUT |
| LOGGED\_IN  | 로그아웃        | LOGGED\_OUT |
| LOGGING\_IN | 로그인 실패 (3회) | LOCKED      |
| LOCKED      | 시간 경과       | LOGGED\_OUT |

이 예시는 사용자 인증 시스템의 상태 전이를 모델링한 것으로, 사용자가 로그인 과정에서 어떤 상태로 이동하는 지를 명확하게 보여준다. 예를 들어, 사용자가 잘못된 비밀번호를 여러 번 입력하면 계정이 잠기고, 일정 시간이 지나야 다시 로그아웃 상태로 돌아갈 수 있다. 이처럼 복잡한 흐름을 FSM으로 명확하게 정의함으로써 시스템의 동작을 더 잘 이해하고 구현할 수 있다.

### 예제: 몬스터

FSM의 경우 게임 AI 또는 AI를 위한 시뮬레이션이나 Animator등에 많이 사용된다. 예를 들면 우리가 어떤 게임을 만들고 몬스터 AI를 설계해야 한다고 가정하자.

몬스터의 3가지 행동 패턴은 다음과 같다. 우리는 몬스터에게 다음과 같은 임무를 주려고 한다.
몬스터에 대기, 이동, 공격 3가지 Action을 수행하는 상태를 제공하며, 각각의 상태는 특정 조건에 따라 전이 될 수 있다. 

1. Idle
	- 아무런 행동없이 대기 상태
	- 플레이어가 인지 가능 범위 안에 있다면 Move로 상태 전환
	- 플레이어가 공격 가능 범위 안에 있다면 Attack 상태 전환
2. Move
	- 이동
	- 인지 가능 범위를 벗어나면 Idle 상태 전환
	- 공격 가능 범위 안에 있다면 Attack 상태 전환
3. Attack
	- 공격 상태
	- 인지 가능 범위를 벗어나면 Idle 상태 전환
	- 공격 범위를 벗어나면 인지 가능 범위에 있다면 Move로 전환

3가지 특징을 이용해서 그래프를 그려보자


![[몬스터 AI 상태 오토 마타(draw).svg]]

| 현재 상태  | x > 인지 범위 | 공격 범위 < x <= 인지 범위 | x <= 공격 범위 |     |
| ------ | --------- | ------------------ | ---------- | --- |
| Idle   | Idle      | Move               | Attack     |     |
| Move   | Idle      | Idle               | Attack     |     |
| Attack | Idle      | Move               | Attack     |     |

위 그림을 통해 상태들이 어떤 액션을 가지고 어떤 전이(Transition)를 가지는 지 쉽게 파악 가능하다. 위의 각 상태들은 2가지 전이 방식을 가진다.(밖으로 나가는 Edge) 그리고 Idle은 대기 상태, Move는 이동 상태, Attack은 공격 상태임을 쉽게 알 수 있다.

### 개발에서 FSM이 유용한 경우

FSM은 다양한 상황에서 유용하게 사용될 수 있다. 몇 가지 대표적인 사례를 살펴보자:

1. **게임 개발**: 게임 캐릭터의 상태(예: 대기, 걷기, 뛰기, 공격)를 정의하고 각 상태 간의 전이를 다루기 위해 FSM을 많이 사용해. 이로 인해 캐릭터의 동작을 명확하고 일관성 있게 유지할 수 있어.
2. **UI/UX 상태 관리**: 버튼의 상태(예: 비활성화, 활성화, 클릭됨)를 관리할 때도 FSM이 유용해. 복잡한 인터페이스의 다양한 상태 전이를 체계적으로 정의할 수 있지.
3. **통신 프로토콜**: 특정 상태에서 명령을 처리하고 그에 따라 상태를 전이하는 방식으로 네트워크 통신을 관리할 때 FSM을 사용할 수 있어. 프로토콜의 상태 전이를 명확히 정의함으로써 오류를 줄이고 안정성을 높일 수 있어.

### FSM의 장점

- **직관적 모델링**: 복잡한 시스템을 이해하기 쉽게 상태와 전이로 분해할 수 있어. 이는 시스템의 동작을 시각적으로 표현하고 추적하기에 유리해.
- **유지보수성**: 상태의 변경 및 추가가 명확하게 정의되어 있어서 유지보수가 쉬워. 코드의 각 상태와 전이가 명확히 드러나기 때문에 새로운 기능을 추가하거나 버그를 수정할 때 용이해.
- **재사용성**: FSM 구조를 재사용해 비슷한 상태 관리 로직을 손쉽게 적용할 수 있어. 예를 들어, 한 모바일 게임 프로젝트에서 캐릭터의 상태를 FSM으로 모델링했을 때, 공격, 방어, 이동 같은 상태 전이를 명확히 정의함으로써 팀원들이 쉽게 이해하고 유지보수할 수 있었어. 이 덕분에 캐릭터 동작의 일관성을 유지하면서 새로운 동작을 추가할 때도 코드의 복잡도가 크게 증가하지 않았지.

### 현대 개발에서 FSM 사용 사례

FSM은 많은 라이브러리와 프레임워크에서 활용되고 있어. 프론트엔드 개발에서는 상태 관리 라이브러리인 **XState**가 복잡한 UI 상태 전이를 관리하기 위해 사용돼. 백엔드나 서비스 개발에서도 **Spring State Machine** 같은 도구들이 상태 기반 워크플로우를 구현할 때 유용해. 이러한 도구들은 복잡한 비즈니스 로직을 명확하게 표현하고 유지보수성을 높이는 데 기여하고 있어.

## 질문 & 확장

**유한 상태 기계**는 복잡한 시스템을 상태와 전이로 분해하여 효율적으로 관리할 수 있는 매우 유용한 도구다. 상태 기반의 논리가 필요할 때 FSM을 활용하면 코드의 가독성과 유지보수성을 크게 높일 수 있다. 특히 상태 전이가 명확하고 상태의 수가 유한한 시스템에서는 FSM이 매우 효과적이다. 다음에 상태 관리가 필요한 프로젝트를 맡게 된다면,. 이러한 이론적 개념을 실제 프로젝트에 적용함으로써 더욱 견고하고 유지 보수하기 쉬운 소프트웨어를 개발해 보고 싶다.

- FSM은 상태들의 집합과 각 상태들의 전이 조건으로 정의될 수 있다.
- 각각의 상태들은 노드와 그 노드를 연결하는 그래프로 표현 가능하다.

## 출처(링크)

- [유한 상태 기계 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%95%9C_%EC%83%81%ED%83%9C_%EA%B8%B0%EA%B3%84)
- [유한상태기계(Finite State Machine, FSM) 이란?](https://skmagic.tistory.com/310)
- [Spring Statemachine 이론부터 토이 프로젝트까지](https://dev.gmarket.com/52)
- [\[오토마타 이론\] 유한 오토마타 기본 (언어, DFA & NFA)](https://minimumcat.tistory.com/7)
- [[Difference between DFA and NFA - GeeksforGeeks.pdf]]
- [[lec4.pdf]]

## 연결 노트

- [[State Machine 구현]]


