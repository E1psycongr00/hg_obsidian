---
tags:
  - 객체지향
aliases: 
created: 2025-04-15
title: ⌨️ 객체 설계 효율 적인 코드 (오브젝트 - 조용호)_java (2025-04-15)
note-type: CODE
language: java
completed: false
archive: false
---


## 코드

### Code

[codediagram.io/app/shares/?token=3dea3ee4](https://www.codediagram.io/app/shares?token=3dea3ee4)

### 결과

각 객체들의 자율성이 개선


>[!code]- Bag.java
>![[Pasted image 20250415181728.png]]
>Bag에 hold 메서드를 만들어서 상태를 가방이 관리.

>[!code]- Audience.java
>![[Pasted image 20250415182000.png]]
>직접 Bag에 접근하지 않고 buy를 메서드를 만들어 Bag 인터페이스에 의존함.

>[!code]- value object 개선
>Invitation과 Ticket은 데이터 타입임. 그래서 Record 형태로 사용

>[!code]- TicketOffice.java
>![[Pasted image 20250415182330.png]]
>sellToAmount 메서드 생성 및 인터페이스에 의존. Audience 에 새롭게 의존함

나머지는 각각 인터페이스에 의존함.

## 설명

![after.svg](file:///c%3A/programming/java/objects_1/draw/after.svg)

개선된 코드는 객체가 구현에 의존하지 않는다. 그 말은 논리 로직 구현을 위해 다른 객체의 상태를 직접 제어하는 것이 아니라, 각각의 객체가 자신의 상태를 관리하고, 인터페이스를 외부에 제공한다. 이를 통해 내부 구현 로직이 변경해도 유연한 설계가 가능해진다. 

하지만 반대로 의존성이 높아지는 문제가 발생할 수 있다.
TicketOffice 코드의 경우 TicketOffice의 객체가 가지는 의미 때문에 좀 더 역할에 맞는 메서드 이름과 함께 인터페이스를 제공하지만 이는 의존성을 높이는 결과를 낳았다. 자율성과 의존성 사이의 트레이드 오프(trade off)가 발생한 것이다. 

저자의 경우에는 sellTicketTo 메서드를 새로 만드는 것보다 plusAmount를 선호한다고 한다. 그 이유는 amount를 외부에서 관리하게 되는 문제가 생길 수는 있지만, 

```java
plusAmount(audience.buy(getTicket))
```

자체가 이미 어느정도 직관적인 코드이기 때문이다. 물론 office에서 ticket를 관리하기 때문에 이런 각각의 상태 수정을 외부에 맞기면 버그 위험성도 존재하긴 한다.

하지만 설계는 팀의 목적 또는 균형에 따라 잘 맞게 설계해야 한다고 생각한다.