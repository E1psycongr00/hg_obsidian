---
tags: 
  - 디자인패턴
  - 프로토타입패턴
  - 생성패턴
  - 장단점분석
  - GoF
aliases: []
created: 2025-06-09
title: 📝 프로토타입 패턴의 장점과 단점
note-type: COMMON
difficulty: "입문"
time-to-understand: "5분"
---

# 📝 프로토타입 패턴의 장점과 단점

## 장점 (Advantages)

### 1. 성능 향상 🚀
- **복잡한 객체 생성 비용 절약**: 이미 생성된 객체를 복사하는 것이 처음부터 만드는 것보다 빠름
- **초기화 과정 생략**: 복잡한 설정이나 계산 과정을 반복하지 않아도 됨
- **메모리 효율성**: 공통 부분은 공유하고 필요한 부분만 복사 가능

```
새로 생성: 객체 생성 → 초기화 → 설정 → 완료 (느림)
프로토타입: 기존 객체 복사 → 완료 (빠름)
```

### 2. 유연성 증대 🔄
- **런타임 객체 추가**: 실행 중에 새로운 프로토타입을 동적으로 추가/제거 가능
- **클래스에 의존하지 않음**: 구체적인 클래스를 몰라도 객체 생성 가능
- **다양한 구성 조합**: 여러 프로토타입을 조합하여 새로운 객체 생성

### 3. 코드 단순화 📝
- **복잡한 생성 로직 숨김**: 클라이언트는 단순히 `clone()` 호출만 하면 됨
- **팩토리 클래스 불필요**: 별도의 팩토리 클래스 없이도 객체 생성 가능
- **일관된 인터페이스**: 모든 프로토타입이 동일한 복제 인터페이스 제공

### 4. 상태 보존 💾
- **현재 상태 복사**: 객체의 현재 상태를 그대로 복사하여 새 객체 생성
- **설정 재사용**: 복잡한 설정을 가진 객체를 템플릿으로 활용
- **점진적 수정**: 기존 객체를 복사한 후 일부만 수정하여 사용

## 단점 (Disadvantages)

### 1. 복제 구현의 복잡성 🔧
- **깊은 복사 처리**: 참조 타입 필드가 많을 경우 복제 로직이 복잡해짐
- **순환 참조 문제**: 객체 간 순환 참조가 있을 때 무한 루프 위험
- **clone() 메소드 구현**: 각 클래스마다 적절한 복제 로직을 구현해야 함

```java
// 복잡한 깊은 복사 예시
public Person clone() {
    Person cloned = (Person) super.clone();
    cloned.address = this.address.clone();        // 참조 객체 복사
    cloned.hobbies = new ArrayList<>(this.hobbies); // 컬렉션 복사
    // ... 더 많은 필드들
    return cloned;
}
```

### 2. 메모리 사용량 증가 💾
- **중복 데이터**: 같은 데이터를 여러 객체가 각각 보유
- **깊은 복사 비용**: 모든 참조 객체를 새로 생성하면 메모리 사용량 급증
- **가비지 컬렉션 부담**: 많은 복사본으로 인한 GC 압박

### 3. 타입 안전성 문제 ⚠️
- **캐스팅 필요**: `clone()` 메소드가 `Object`를 반환하는 경우 타입 캐스팅 필요
- **런타임 오류**: 잘못된 타입 캐스팅으로 인한 `ClassCastException` 위험
- **제네릭 지원 한계**: 일부 언어에서 제네릭과의 호환성 문제

### 4. 디버깅 어려움 🐛
- **객체 추적 곤란**: 어떤 프로토타입에서 복사된 객체인지 추적하기 어려움
- **상태 공유 버그**: 얕은 복사로 인한 예상치 못한 상태 공유
- **복제 과정 불투명**: 복제 과정에서 발생하는 문제 파악이 어려움

## 사용 시 고려사항

### 언제 사용하면 좋을까? ✅
- **객체 생성 비용이 높은 경우**
  - 데이터베이스 조회가 필요한 객체
  - 네트워크 통신이 필요한 객체
  - 복잡한 계산을 통해 생성되는 객체

- **비슷한 객체를 많이 만들어야 하는 경우**
  - 게임의 몬스터, 아이템 생성
  - 문서 템플릿 복사
  - 설정 객체 복제

- **런타임에 객체 타입이 결정되는 경우**
  - 사용자 입력에 따른 동적 객체 생성
  - 플러그인 시스템

### 언제 사용하지 말아야 할까? ❌
- **단순한 객체인 경우**
  - 생성 비용이 낮은 객체
  - 필드가 적고 단순한 객체

- **불변 객체인 경우**
  - 상태가 변하지 않는 객체
  - 복사할 필요가 없는 객체

- **복제 로직이 너무 복잡한 경우**
  - 순환 참조가 많은 객체
  - 외부 리소스에 의존하는 객체

## 다른 패턴과의 비교

| 패턴 | 프로토타입 | 팩토리 메소드 | 빌더 |
|------|------------|---------------|------|
| **생성 방식** | 복제 | 새로 생성 | 단계별 생성 |
| **성능** | 빠름 | 보통 | 느림 |
| **유연성** | 높음 | 보통 | 높음 |
| **구현 복잡도** | 중간 | 낮음 | 높음 |

## 실무 팁 💡

### 1. 복제 전략 선택
```java
// 선택적 복사 구현
public Person clone(boolean deepCopyAddress) {
    Person copy = (Person) super.clone();
    if (deepCopyAddress) {
        copy.address = this.address.clone();
    }
    return copy;
}
```

### 2. 복제 검증
```java
// 복제 결과 검증
public void validateClone(Object original, Object cloned) {
    assert original != cloned;           // 다른 객체
    assert original.equals(cloned);      // 같은 내용
}
```

### 3. 성능 모니터링
- 복제 횟수와 시간 측정
- 메모리 사용량 모니터링
- 필요시 캐싱 전략 적용

## 관련 노트
- [[04. Practice Notes/📝 얕은 복사와 깊은 복사|📝 얕은 복사와 깊은 복사]]
- [[04. Practice Notes/📝 프로토타입 패턴과 다른 생성 패턴 비교|📝 프로토타입 패턴과 다른 생성 패턴 비교]]
- [[02. MOC/🏛️ 프로토타입 패턴|🏛️ 프로토타입 패턴]] - 상위 MOC 