---
tags:
  - OS
  - Process
  - Synchronization
  - Thread
aliases:
  - OS에서 DeadLock 문제 해결하기
---
작성 날짜: 2024-01-22
작성 시간: 15:12

## 주제: #미완 #OS #Synchronization #Process #Thread 

----
## 내용(Content)
### OS의 데드락 해결 방법
>[!summary] 데드락을 해결하는 4가지 방법
>- Dead Lock 방지
>- Dead Lock 회피
>- Dead Lock 방지와 복구
>- Dead Lock 무시

#### Dead Lock 방지
Dead Lock을 방지한다는 것은 [[DeadLock#데드락의 발생 조건|데드락의 4가지 발생 조건]]중 하나라도 만족을 못하게 디자인하는 것이다.

>[!tip]- mutual exclusion 방지
>리소스를 하나의 쓰레드가 아닌 여러 쓰레드가 동시에 접근하도록 허용함. 이 방법은 실제로 해결하기엔 문제가 너무 많은 방법
>

>[!tip]- hold and wait 방지
>- 사용한 리소스를 모두 획득한 후 시작
>- 리소스를 전혀 가지지 않은 상태에서만 리소스 요청
>
>![[Dead Lock 예시2(draw)]]
>예를 들면 위 그림에서 우측 차량이 2번으로 접근하려 할 때 다음 작업은 1번을 향해 가므로 윗 차량이 1번으로 못 가게 하고 2번 차량을 통과시킨 후 동작시키는 것이다. 
>
>**문제점1**
>이것의 문제점은 우측 차량이 너무 느려서 늦게 통과한다면 1번을 통과하려는 윗차량은 가만히 있으니 1번 리소스는 사용하지 않게 되니 효율이 떨어진다. 
>
>**문제점2**
>1번 2번을 모두 확보가 쉽지 않을 수도 있다. 그러면 우측 차량을 계속해서 갈 수 없고 우선 순위가 밀리기 때문에 Thread Starvation이 발생할 수 있다.

>[!tip]- no Preemption 방지
>추가적인 리소스를 기다려야 한다면 이미 획득한 리소스를 다른 프로세스가 선점하도록 한다. 사실 이와 같은 방법은 CPU 스케줄링에서 굉장히 많이 사용된다. [[CPU 스케줄링 알고리즘#Round Robin(RR)|RR]] 알고리즘을 살펴보면 
>
## 질문 & 확장

(없음)

## 출처(링크)


## 연결 노트










