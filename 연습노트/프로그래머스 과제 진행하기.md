작성 날짜: 2023-12-27
작성 시간: 21:43

## 주제: #미완 #솔루션 #알고리즘 #객체지향 

----

## 문제 & 원인
[과제 진행하기 사이트](https://school.programmers.co.kr/learn/courses/30/lessons/176962)

문제를 해결했지만 코드가 굉장히 복잡해서 리팩토링이 필요하다.

```java
private static class Work {  
       private final String name;  
       private final int startMinute;  
       private int restMinute;  
  
       public Work(String name, int startMinute, int restMinute) {  
          this.name = name;  
          this.startMinute = startMinute;  
          this.restMinute = restMinute;  
       }  
  
       public void rest(int minute) {  
          this.restMinute -= minute;  
       }  
  
       @Override  
       public String toString() {  
          return "Work{" +  
             "name='" + name + '\'' +  
             ", startMinute=" + startMinute +  
             ", restMinute=" + restMinute +  
             '}';  
       }  
}  
```


```java
class Solution {  
    public String[] solution(String[][] plans) {  
       Work[] works = makePlans(plans);  
       Deque<Work> workStack = new ArrayDeque<>();  
       List<String> answer = new ArrayList<>();  
       for (Work work : works) {  
          int currTime = 0;  
          while (!workStack.isEmpty()) {  
             Work peek = workStack.peekLast();  
             currTime = (currTime == 0) ? peek.startMinute + peek.restMinute : currTime + peek.restMinute;  
             if (currTime <= work.startMinute) {  
                workStack.pollLast();  
                answer.add(peek.name);  
             } else {  
                peek.rest(work.startMinute - (currTime - peek.restMinute));  
                break;             }  
          }  
          workStack.addLast(work);  
       }  
       while (!workStack.isEmpty()) {  
          answer.add(workStack.pollLast().name);  
       }  
       return answer.toArray(new String[0]);  
    }  
  
    private Work[] makePlans(String[][] plans) {  
       return Arrays.stream(plans)  
          .map(plan -> new Work(plan[0], parseMinute(plan[1]), Integer.parseInt(plan[2])))  
          .sorted(Comparator.comparingInt(w -> w.startMinute))  
          .toArray(Work[]::new);  
    }  
  
    private int parseMinute(String time) {  
       return LocalTime.parse(time).toSecondOfDay() / 60;  
    }  
  
}
```

문제점은 workStack내부에서 데이터 관리를 외부에서 하고 있고 내부 Work 데이터를 수정하고 있다. 데이터 클래스가 불변하지 않으면 실수할 여지가 있고, 멀티 쓰레드에서는 사용하기 힘들다.
## 해결 방안


## 질문 & 확장

## 출처(링크)
- https://school.programmers.co.kr/learn/courses/30/lessons/176962

## 연결 노트
