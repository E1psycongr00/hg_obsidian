---
tags:
  - 솔루션
  - 이분탐색
  - binary_search
aliases: 
date: 2024-07-04
title: 153. Find Minimum in Rotated Sorted Array
---
작성 날짜: 2024-07-04
작성 시간: 21:15

#미완 #솔루션 #binary_search #이분탐색 

----

## 문제 & 원인

회전된 배열에서 가장 작은 value를 찾는 문제이다. 

>[!example]
>`[4,5,6,7,0,1,2]` 는 `[0,1,2,4,5,6,7]`에서 4번 회전된 것이다.
>1. `[7,0,1,2,4,5,6]`
>2. `[6,7,0,1,2,4,5]`
>3. `[5,6,7,0,1,2,4]`
>4. `[4,5,6,7,0,1,2]`
 
여기서 회전을 하면 우뚝 솓은 부분이 존재하며, 이 부분을 기준으로 회전이 일어났는지 안 일어났는지 알 수 있다.

![[rotated Sorted Array.png]]

오름차 순으로 정렬된 데이터의 경우 간단하게 조건을 설정하면 되지만 이렇게 뚝 끊긴 데이터의 경우 다른 조건이 필요하다. 일반적으로 이런 회전된 그래프는 하나의 뚝 끊긴 부분이 존재하는데 이때 뚝 끊긴 부분의 오른쪽에 최소 값이 반드시 존재하게 된다. 
## 해결 방안

### Condition 설정하기

이분 탐색을 하기로 결정했고 최소값의 index를 구하려고 한다. 이 때 최소값 인덱스를 구하기 위해서는 위로 우뚝 솓은 값이 아니면 index를 업데이트하고 그렇지 않는 경우는` lo = mid + 1`로 업데이트한다.

이런 경우 

### code

```java
class Solution {  
    public int findMin(int[] nums) {  
       int low = 0;  
       int high = nums.length;  
       Condition condition = (mid, hi) -> nums[mid] > nums[hi];  
       int idx = binarySearch(low, high, condition);  
       return nums[idx];  
    }  
  
    interface Condition {  
       boolean test(int x, int target);  
    }  
  
    private int binarySearch(int lo, int hi, Condition condition) {  
       int result = -1;  
       while (lo <= hi) {  
          int mid = lo + (hi - lo) / 2;  
          if (condition.test(mid, hi)) {  
             result = mid;  
             hi = mid + 1;  
          } else {  
             lo = mid - 1;  
          }  
       }  
       return result;  
    }  
}
```
## 질문 & 확장

(없음)

## 출처(링크)

- https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/

## 연결 노트

- [[일반적인 ParametricSearch 만들기(통합)]]
- [[이분 탐색]]
