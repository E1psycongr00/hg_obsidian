---
tags:
  - 미완
  - 솔루션
aliases: 
date: 2024-12-02
title: 엔티티 영속과 낙관적인 락 문제
---
작성 날짜: 2024-12-02
작성 시간: 16:22


----

## 문제 & 원인

>**org.springframework.orm.ObjectOptimisticLockingFailureException**: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect): com.example.module_ex.member.domain.Member#1

테스트 시에 repository에 다음과 같은 코드를 작성했다.

```java
    @Test
    @Transactional
    void addInventoryItem_성공() {
        // given
        Member inputMember = new Member(1L, "test@test.com", new ArrayList<>());
        Member member = memberRepository.save(inputMember);
        Long inventoryId = 1L;
    }
}
```

그 결과 위와 같은 ObjectOptimisticLockingFailureException이 발생했다.

결론부터 말하자면 이 문제의 원인은 Member 엔티티에서 Id 생성 전략을 Identity로 지정했는데 미리 ID가 충돌해서 문제가 발생한 것이다. 

### JPA save 동작 과정

JPA에 repository의 save는 persist와 merge 방식으로 영속성을 관리한다.

```java
// JpaRepository의 save() 메서드 내부 동작
public <S extends T> S save(S entity) {
    // isNew() 판단 기준
    // 1. @Version이나 @LastModifiedDate 필드가 null인가?
    // 2. ID가 null인가?
    // 3. ID가 primitive type이면서 0인가?
    if (entityInformation.isNew(entity)) {
        em.persist(entity);  // 새로운 엔티티
    } else {
        em.merge(entity);    // 기존 엔티티
    }
}
```

**persist 동작:**

```java
void persist(Entity entity) {
    // 1. 영속성 컨텍스트에 엔티티 등록
    persistenceContext.addNew(entity);
    
    // 2. IDENTITY 전략인 경우
    if (isIdentityStrategy) {
        // INSERT 즉시 실행하여 ID 획득
        executeInsert(entity);
    }
    // 다른 전략의 경우 트랜잭션 커밋 시점까지 지연
}
```

**merge 동작:**

```java
Entity merge(Entity entity) {
    // 1. DB에서 해당 ID의 엔티티 조회
    Entity managedEntity = entityManager.find(Entity.class, entity.getId());
    
    if (managedEntity == null) {
        // 2-1. 없으면 새로운 엔티티로 저장
        return persist(entity);
    } else {
        // 2-2. 있으면 기존 엔티티 업데이트
        managedEntity.updateFrom(entity);
        return managedEntity;
    }
}
```

## 해결 방안


## 질문 & 확장

(없음)

## 출처(링크)


## 연결 노트
