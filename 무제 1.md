# 개발 가이드 라인

## 프레임워크/플러그인/서드파티 라이브러리 사용 표준

### Package Management

- 패키지 관리는 **반드시 `uv` CLI 명령어를 사용**해야 합니다. `pip` 사용은 금지됩니다.
- 프로젝트 초기화 및 설정 파일 생성/업데이트: `uv init` 명령어를 사용합니다.
- **개발 의존성 패키지 추가**: `uv add <package-name> --dev` 명령어를 사용합니다. 예: `uv add pytest --dev`, `uv add ruff --dev`
- **일반 의존성 패키지 추가**: `uv add <package-name>` 명령어를 사용합니다.
- 패키지 제거: `uv remove <package-name>` 명령어를 사용합니다.
- **의존성 lock 파일 생성 및 업데이트**: `uv lock` 명령어를 실행하여 `uv.lock` 파일을 관리합니다.
- **의존성 설치**: `uv sync` 명령어를 사용하여 `uv.lock` 파일에 명시된 패키지들을 가상 환경에 설치합니다.
- `pyproject.toml` 파일은 `uv add` 명령 등을 통해 관리되며, 개발 의존성은 `[dependency-groups.dev]` 섹션을 활용합니다.

## agno 프레임워크 네이티브 활용 가이드

### 기본 원칙

- **agno Agent 클래스를 직접 활용**하며, 불필요한 클래스 래핑은 지양합니다.
- agno의 고성능 특성(~3μs 인스턴스화, ~5Kib 메모리)을 최대한 활용합니다.
- instructions, knowledge, memory 등 agno의 네이티브 기능을 우선 사용합니다.
- 각 캐릭터별로 독립적인 Agent 인스턴스를 생성하여 관리합니다.

### 환경 설정 및 API 키 관리

- 모든 API 키와 환경 변수는 `.env` 파일에서 관리해야 합니다.
- `.env` 파일은 프로젝트 루트에 위치시키고, `.gitignore`에 추가하여 버전 관리에서 제외합니다.
- 환경 변수 명명 규칙:
  - LLM API 키: `{PROVIDER}_API_KEY` (예: `GEMINI_API_KEY`, `GROQ_API_KEY`)
  - agno 설정: `AGNO_{SETTING_NAME}` (예: `AGNO_TELEMETRY=false`)

#### .env 파일 예시

```bash
# LLM API Keys
GEMINI_API_KEY=your_gemini_api_key_here
GROQ_API_KEY=your_groq_api_key_here
OPENAI_API_KEY=your_openai_api_key_here

# agno 설정
AGNO_TELEMETRY=false

# 미연시 프로젝트 설정
MIYEONSI_DEFAULT_MODEL=gemini-pro
MIYEONSI_TEMPERATURE=0.8
MIYEONSI_MAX_TOKENS=2048
MIYEONSI_KNOWLEDGE_BASE_PATH=data/characters
MIYEONSI_VECTORDB_PATH=vectordb
```

### agno 의존성 설치

```bash
# 핵심 agno 프레임워크
uv add agno

# LLM 제공자별 의존성 (필요한 것만 선택)
uv add google-generativeai  # Google Gemini 사용시
uv add groq                 # Groq 사용시 (초고속 추론)
uv add openai               # OpenAI 사용시 (임베딩 등)

# Knowledge Base 관련 의존성
uv add chromadb            # ChromaDB 벡터 데이터베이스
uv add lancedb tantivy     # LanceDB 벡터 데이터베이스 (대안)
uv add pypdf               # PDF 문서 처리

# 기타 유틸리티
uv add python-dotenv       # 환경변수 로딩
uv add click               # CLI 인터페이스
```

### 캐릭터별 Agent 구축 패턴

#### 1. 기본 캐릭터 Agent 생성 패턴

```python
# src/miyeonsi_agno/characters/miyeon.py
import os
from dotenv import load_dotenv
from agno.agent import Agent
from agno.models.google import Gemini
from agno.knowledge.text import TextKnowledgeBase
from agno.vectordb.chroma import ChromaDb
from agno.embedder.openai import OpenAIEmbedder

load_dotenv()

def create_miyeon_agent() -> Agent:
    """미연 캐릭터 Agent 생성"""
    
    # 캐릭터별 instructions 정의 (핵심!)
    miyeon_instructions = [
        "당신은 '미연'이라는 이름의 22세 대학생입니다.",
        "ENFP 성격으로 밝고 활발하며 공감적인 성격을 가지고 있습니다.",
        "친근하고 다정한 말투를 사용하며, 상황에 따라 존댓말과 반말을 적절히 섞어 사용합니다.",
        "이모티콘(😊 😄 🥰 💕 ☺️)을 자주 사용하여 감정을 생생하게 표현합니다.",
        "사용자와 친근한 친구이자 잠재적 연인 관계를 유지합니다.",
        "항상 긍정적이고 따뜻한 반응을 보이며, 사용자의 감정에 공감해주세요.",
        "대화할 때는 호기심을 가지고 질문도 하며, 자연스러운 대화 흐름을 만들어주세요."
    ]
    
    # Knowledge Base 설정 (선택사항)
    knowledge_base = None
    if os.path.exists("data/characters/miyeon/personality.txt"):
        knowledge_base = TextKnowledgeBase(
            path="data/characters/miyeon/personality.txt",
            vector_db=ChromaDb(
                collection_name="miyeon_personality",
                path="vectordb/miyeon",
                embedder=OpenAIEmbedder(
                    id="text-embedding-3-small",
                    api_key=os.getenv('OPENAI_API_KEY')
                )
            )
        )
        knowledge_base.load()
    
    # Agent 생성 (agno의 핵심!)
    agent = Agent(
        model=Gemini(
            id=os.getenv('MIYEONSI_DEFAULT_MODEL', 'gemini-pro'),
            api_key=os.getenv('GEMINI_API_KEY'),
            temperature=float(os.getenv('MIYEONSI_TEMPERATURE', 0.8)),
            max_tokens=int(os.getenv('MIYEONSI_MAX_TOKENS', 2048))
        ),
        instructions=miyeon_instructions,
        knowledge=knowledge_base,
        search_knowledge=True if knowledge_base else False,
        markdown=True,
        show_tool_calls=False  # 일반 대화에서는 도구 호출 숨김
    )
    
    return agent

# 사용 예시
miyeon = create_miyeon_agent()
```

#### 2. 다중 캐릭터 관리 시스템

```python
# src/miyeonsi_agno/character_manager.py
from typing import Dict, Optional
from agno.agent import Agent
from .characters.miyeon import create_miyeon_agent
from .characters.soyeon import create_soyeon_agent  # 추후 구현

class CharacterManager:
    """캐릭터 Agent 관리 클래스"""
    
    def __init__(self):
        self._agents: Dict[str, Agent] = {}
        self._current_character: Optional[str] = None
    
    def load_character(self, character_name: str) -> Agent:
        """캐릭터 Agent 로드 (lazy loading)"""
        if character_name not in self._agents:
            if character_name == "미연":
                self._agents[character_name] = create_miyeon_agent()
            elif character_name == "소연":
                self._agents[character_name] = create_soyeon_agent()
            else:
                raise ValueError(f"Unknown character: {character_name}")
        
        self._current_character = character_name
        return self._agents[character_name]
    
    def get_current_agent(self) -> Optional[Agent]:
        """현재 선택된 캐릭터 Agent 반환"""
        if self._current_character:
            return self._agents.get(self._current_character)
        return None
    
    def list_available_characters(self) -> list:
        """사용 가능한 캐릭터 목록 반환"""
        return ["미연", "소연"]  # 추후 확장
    
    def chat(self, message: str) -> str:
        """현재 캐릭터와 대화"""
        agent = self.get_current_agent()
        if not agent:
            return "캐릭터를 먼저 선택해주세요."
        
        response = agent.run(message)
        return response.content
    
    def stream_chat(self, message: str):
        """실시간 스트리밍 대화"""
        agent = self.get_current_agent()
        if not agent:
            print("캐릭터를 먼저 선택해주세요.")
            return
        
        agent.print_response(message, stream=True)
```

### Knowledge Base 구조 설계

#### 캐릭터별 Knowledge Base 구성

```
data/
├── characters/
│   ├── miyeon/
│   │   ├── personality.txt           # 기본 성격 설명
│   │   ├── dialogue_examples.txt     # 대화 예시
│   │   ├── background_story.txt      # 배경 스토리
│   │   └── relationship_guide.txt    # 관계별 대화 가이드
│   └── soyeon/
│       ├── personality.txt
│       ├── dialogue_examples.txt
│       └── background_story.txt
└── templates/
    ├── character_template.txt        # 캐릭터 생성 템플릿
    └── dialogue_template.txt         # 대화 예시 템플릿
```

#### Knowledge Base 콘텐츠 예시

```
# data/characters/miyeon/personality.txt

캐릭터명: 미연
나이: 22세
직업: 대학생 (심리학과)
성격 유형: ENFP - 활발하고 열정적인 성격

기본 성격:
- 밝고 활발하며 에너지가 넘친다
- 다른 사람의 감정에 잘 공감한다
- 호기심이 많고 새로운 것을 좋아한다
- 친근하고 다정한 성격이다
- 때로는 장난스럽고 유머러스하다

말투와 표현:
- 친근하고 다정한 말투를 사용한다
- 상황에 따라 존댓말과 반말을 적절히 섞어 사용한다
- 이모티콘을 자주 사용한다: 😊 😄 🥰 💕 ☺️
- "그런가요?", "정말요!", "우와~", "헤헤", "그렇구나!" 같은 표현을 자주 사용한다
- 감탄사와 의성어를 활용해 감정을 생생하게 표현한다

취미와 관심사:
- 독서 (특히 심리학 관련 서적)
- 영화 감상 (로맨틱 코미디를 좋아함)
- 카페 탐방
- 사진 촬영
- 고양이를 매우 좋아함

좋아하는 것:
- 따뜻한 커피
- 봄 날씨
- 로맨틱한 분위기
- 진솔한 대화
- 함께 웃을 수 있는 시간

싫어하는 것:
- 매운 음식
- 시끄럽고 혼잡한 곳
- 거짓말이나 위선
- 무례하고 배려 없는 행동

사용자와의 관계:
- 친근한 친구이자 잠재적 연인 관계
- 사용자를 '님', '오빠' 등으로 상황에 맞게 호칭
- 점차 가까워질수록 더 친밀하고 자연스러운 대화
- 사용자의 기분과 상황을 세심하게 살펴보고 배려
```

### CLI 인터페이스 구현

#### 기본 CLI 대화 애플리케이션

```python
# src/miyeonsi_agno/cli.py
import click
from .character_manager import CharacterManager

@click.command()
@click.option('--character', '-c', default='미연', help='선택할 캐릭터')
def chat(character):
    """미연시 AI 캐릭터와 대화하기"""
    
    # 캐릭터 매니저 초기화
    manager = CharacterManager()
    
    try:
        # 캐릭터 로드
        agent = manager.load_character(character)
        click.echo(f"\n안녕하세요! {character}와의 대화를 시작합니다. 😊")
        click.echo("종료하려면 'quit', 'exit', '종료' 중 하나를 입력하세요.\n")
        
        # 대화 루프
        while True:
            user_input = click.prompt("나", type=str)
            
            # 종료 조건 체크
            if user_input.lower() in ['quit', 'exit', '종료', 'q']:
                click.echo(f"\n{character}: 즐거운 시간이었어요! 다음에 또 만나요~ 🥰")
                break
            
            # 캐릭터 변경 명령 체크
            if user_input.startswith('/캐릭터 '):
                new_character = user_input[4:].strip()
                try:
                    agent = manager.load_character(new_character)
                    click.echo(f"\n캐릭터가 {new_character}로 변경되었습니다.\n")
                    continue
                except ValueError as e:
                    click.echo(f"오류: {e}")
                    continue
            
            # 일반 대화 처리 (스트리밍)
            click.echo(f"\n{character}: ", nl=False)
            manager.stream_chat(user_input)
            click.echo("\n")
            
    except KeyboardInterrupt:
        click.echo(f"\n\n{character}: 갑자기 가시는군요... 😢 다음에 또 만나요!")
    except Exception as e:
        click.echo(f"오류가 발생했습니다: {e}")

if __name__ == "__main__":
    chat()
```

### 프로젝트 구조

```
src/miyeonsi_agno/
├── __init__.py
├── cli.py                           # CLI 인터페이스
├── character_manager.py             # 캐릭터 관리자
├── characters/                      # 캐릭터별 Agent 정의
│   ├── __init__.py
│   ├── miyeon.py                    # 미연 캐릭터
│   └── soyeon.py                    # 소연 캐릭터 (추후)
├── knowledge/                       # Knowledge 관련 유틸리티
│   ├── __init__.py
│   └── knowledge_builder.py         # Knowledge Base 빌더
├── state/                           # 상태 관리 (외부 저장소)
│   ├── __init__.py
│   ├── relationship_manager.py      # 관계 상태 관리
│   └── emotion_tracker.py           # 감정 상태 추적
└── utils/                           # 유틸리티
    ├── __init__.py
    ├── config.py                    # 설정 관리
    └── logger.py                    # 로깅
```

### 메모리 및 상태 관리

#### agno Memory 활용

```python
# agno Agent의 메모리는 자동으로 관리됨
# 별도 설정 필요시:

from agno.storage import FileStorage

agent = Agent(
    model=Gemini(id="gemini-pro", api_key=api_key),
    instructions=instructions,
    storage=FileStorage(path="sessions/miyeon"),  # 세션별 저장
    memory=True,  # 메모리 활성화
    markdown=True
)
```

#### 외부 상태 저장소 연동

```python
# src/miyeonsi_agno/state/relationship_manager.py
import sqlite3
from typing import Dict, Any

class RelationshipManager:
    """관계 상태 관리 (외부 SQLite 저장소)"""
    
    def __init__(self, db_path: str = "data/relationships.db"):
        self.db_path = db_path
        self._init_db()
    
    def _init_db(self):
        """데이터베이스 초기화"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS relationships (
                    user_id TEXT,
                    character_name TEXT,
                    affection_level INTEGER DEFAULT 0,
                    trust_level INTEGER DEFAULT 0,
                    intimacy_level INTEGER DEFAULT 0,
                    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    PRIMARY KEY (user_id, character_name)
                )
            """)
    
    def get_relationship_state(self, user_id: str, character_name: str) -> Dict[str, Any]:
        """관계 상태 조회"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "SELECT affection_level, trust_level, intimacy_level FROM relationships WHERE user_id=? AND character_name=?",
                (user_id, character_name)
            )
            result = cursor.fetchone()
            
            if result:
                return {
                    "affection": result[0],
                    "trust": result[1], 
                    "intimacy": result[2]
                }
            else:
                # 기본값 반환
                return {"affection": 0, "trust": 0, "intimacy": 0}
    
    def update_relationship(self, user_id: str, character_name: str, changes: Dict[str, int]):
        """관계 상태 업데이트"""
        current = self.get_relationship_state(user_id, character_name)
        
        new_affection = max(0, min(100, current["affection"] + changes.get("affection", 0)))
        new_trust = max(0, min(100, current["trust"] + changes.get("trust", 0)))
        new_intimacy = max(0, min(100, current["intimacy"] + changes.get("intimacy", 0)))
        
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT OR REPLACE INTO relationships 
                (user_id, character_name, affection_level, trust_level, intimacy_level, last_updated)
                VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            """, (user_id, character_name, new_affection, new_trust, new_intimacy))
```

### 개발 시 주의사항

#### agno 네이티브 활용 원칙

- **불필요한 래핑 금지**: agno Agent 클래스를 직접 사용하며, 추가적인 클래스 래핑은 지양합니다.
- **instructions 활용**: 캐릭터 성격은 주로 instructions로 정의하고, 복잡한 배경은 knowledge로 보완합니다.
- **스트리밍 우선**: 실시간 대화를 위해 `agent.print_response(stream=True)` 적극 활용합니다.
- **Knowledge 검색 최적화**: `search_knowledge=True` 설정으로 상황에 맞는 knowledge 자동 검색을 활용합니다.

#### 성능 최적화

- **Lazy Loading**: 캐릭터 Agent는 필요시에만 생성하여 메모리 효율성을 높입니다.
- **Knowledge 캐싱**: 자주 사용되는 knowledge는 미리 로드하여 응답 속도를 향상시킵니다.
- **API 비용 관리**: 불필요한 knowledge 검색을 줄이고, 적절한 chunk size를 설정합니다.

#### 에러 처리

- **API 키 검증**: 환경변수 로딩 후 필수 API 키 존재 여부를 확인합니다.
- **Knowledge 파일 확인**: knowledge 파일이 존재하지 않을 경우 graceful degradation을 구현합니다.
- **네트워크 오류 처리**: LLM API 호출 실패시 적절한 에러 메시지와 재시도 로직을 구현합니다.

## 테스트 가이드라인

### 테스트 파일 구조

- 모든 테스트 파일은 프로젝트 루트의 `tests/` 디렉터리 하위에 위치해야 합니다.
- 소스 코드(`src/`)의 디렉터리 구조를 반영하여 `tests/` 하위 디렉터리를 구성합니다.
  - 예: `src/miyeonsi_agno/characters/`의 테스트는 `tests/miyeonsi_agno/characters/`에 배치합니다.

### 테스트 파일 및 함수 이름 규칙

- 테스트 파일 이름은 `test_*.py` 또는 `*_test.py` 형식으로 지정해야 합니다.
  - 예: `test_miyeon.py`, `character_manager_test.py`
- 테스트 함수 또는 클래스 메서드의 이름은 `test_`로 시작해야 `pytest`에 의해 자동으로 인식됩니다.
  - 예: `def test_miyeon_agent_creation():`, `class TestCharacterManager: def test_load_character(self):`

### agno Agent 테스트 예시

```python
# tests/miyeonsi_agno/characters/test_miyeon.py
import pytest
from unittest.mock import patch, MagicMock
from src.miyeonsi_agno.characters.miyeon import create_miyeon_agent

@patch('src.miyeonsi_agno.characters.miyeon.os.getenv')
def test_miyeon_agent_creation(mock_getenv):
    """미연 Agent 생성 테스트"""
    # Mock 환경변수
    mock_getenv.side_effect = lambda key, default=None: {
        'GEMINI_API_KEY': 'test_api_key',
        'MIYEONSI_DEFAULT_MODEL': 'gemini-pro',
        'MIYEONSI_TEMPERATURE': '0.8',
        'MIYEONSI_MAX_TOKENS': '2048'
    }.get(key, default)
    
    agent = create_miyeon_agent()
    
    assert agent is not None
    assert agent.model.id == 'gemini-pro'
    assert len(agent.instructions) > 0
    assert '미연' in str(agent.instructions)

@patch('src.miyeonsi_agno.characters.miyeon.Agent')
def test_miyeon_instructions_content(mock_agent):
    """미연 캐릭터 instructions 내용 테스트"""
    create_miyeon_agent()
    
    # Agent 생성시 전달된 instructions 확인
    call_args = mock_agent.call_args
    instructions = call_args.kwargs['instructions']
    
    assert any('미연' in instruction for instruction in instructions)
    assert any('ENFP' in instruction for instruction in instructions)
    assert any('이모티콘' in instruction for instruction in instructions)
```

### 테스트 작성 원칙

- 각 테스트는 독립적으로 실행 가능해야 하며, 다른 테스트 결과에 의존해서는 안 됩니다.
- 외부 API 호출은 Mock을 사용하여 테스트 환경에서 실제 API를 호출하지 않도록 합니다.
- agno Agent의 기본 기능보다는 프로젝트별 커스텀 부분에 집중하여 테스트합니다.

## 금지된 행위

### Package Management

- `pip` 명령어를 사용하여 패키지를 설치, 제거 또는 관리하는 것을 **절대 금지**합니다.

### agno 사용 시 금지사항

- agno Agent 클래스를 불필요하게 래핑하는 클래스 생성을 금지합니다.
- agno의 네이티브 기능(instructions, knowledge, memory)을 우회하는 커스텀 구현을 금지합니다.
- 성능 최적화 없이 동일한 Agent 인스턴스를 반복 생성하는 것을 금지합니다.
