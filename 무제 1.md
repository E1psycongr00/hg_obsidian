# 개발 가이드 라인

## 프레임워크/플러그인/서드파티 라이브러리 사용 표준

### Package Management

- 패키지 관리는 **반드시 `uv` CLI 명령어를 사용**해야 합니다. `pip` 사용은 금지됩니다.
- 프로젝트 초기화 및 설정 파일 생성/업데이트: `uv init` 명령어를 사용합니다.
- **개발 의존성 패키지 추가**: `uv add <package-name> --dev` 명령어를 사용합니다. 예: `uv add pytest --dev`, `uv add ruff --dev`
- **일반 의존성 패키지 추가**: `uv add <package-name>` 명령어를 사용합니다.
- 패키지 제거: `uv remove <package-name>` 명령어를 사용합니다.
- **의존성 lock 파일 생성 및 업데이트**: `uv lock` 명령어를 실행하여 `uv.lock` 파일을 관리합니다.
- **의존성 설치**: `uv sync` 명령어를 사용하여 `uv.lock` 파일에 명시된 패키지들을 가상 환경에 설치합니다.
- `pyproject.toml` 파일은 `uv add` 명령 등을 통해 관리되며, 개발 의존성은 `[dependency-groups.dev]` 섹션을 활용합니다.

## AI 모델 구축 개발 방안 (agno 프레임워크 활용)

### 환경 설정 및 API 키 관리

- 모든 API 키와 환경 변수는 `.env` 파일에서 관리해야 합니다.
- `.env` 파일은 프로젝트 루트에 위치시키고, `.gitignore`에 추가하여 버전 관리에서 제외합니다.
- 환경 변수 명명 규칙:
  - LLM API 키: `{PROVIDER}_API_KEY` (예: `GEMINI_API_KEY`, `OPENAI_API_KEY`)
  - 기타 설정: `MIYEONSI_AGNO_{SETTING_NAME}` (예: `MIYEONSI_AGNO_MODEL_ID`)

#### .env 파일 예시

```bash
# LLM API Keys
GEMINI_API_KEY=your_gemini_api_key_here
OPENAI_API_KEY=your_openai_api_key_here

# AI Model Configuration
MIYEONSI_AGNO_DEFAULT_MODEL=gemini-pro
MIYEONSI_AGNO_MAX_TOKENS=2048
MIYEONSI_AGNO_TEMPERATURE=0.7

# Application Settings
MIYEONSI_AGNO_LOG_LEVEL=INFO
MIYEONSI_AGNO_SESSION_TIMEOUT=3600
```

### agno 프레임워크 의존성 설치

- agno 프레임워크와 관련 의존성을 설치합니다:

```bash
uv add agno
uv add google-generativeai  # Gemini API 사용시
uv add openai               # OpenAI API 사용시 (선택사항)
uv add python-dotenv        # 환경변수 로딩용
```

### AI 에이전트 구축 구조

#### 1. 기본 AI 에이전트 구현 패턴

```python
# src/miyeonsi_agno/agents/base_agent.py
import os
from dotenv import load_dotenv
from agno.agent import Agent
from agno.models.google import Gemini

# 환경변수 로딩
load_dotenv()

class BaseAIAgent:
    """기본 AI 에이전트 클래스"""
    
    def __init__(self, model_id: str = None, instructions: list = None):
        # 환경변수에서 설정 로딩
        self.api_key = os.getenv('GEMINI_API_KEY')
        self.default_model = os.getenv('MIYEONSI_AGNO_DEFAULT_MODEL', 'gemini-pro')
        self.max_tokens = int(os.getenv('MIYEONSI_AGNO_MAX_TOKENS', 2048))
        self.temperature = float(os.getenv('MIYEONSI_AGNO_TEMPERATURE', 0.7))
        
        # 에이전트 초기화
        self.agent = Agent(
            model=Gemini(
                id=model_id or self.default_model,
                api_key=self.api_key,
                max_tokens=self.max_tokens,
                temperature=self.temperature
            ),
            instructions=instructions or self._get_default_instructions(),
            markdown=True
        )
    
    def _get_default_instructions(self) -> list:
        """기본 인스트럭션 정의"""
        return [
            "자연스러운 한국어로 응답하세요.",
            "친근하고 예의바른 톤을 유지하세요.",
            "사용자의 질문에 정확하고 도움이 되는 답변을 제공하세요."
        ]
    
    def generate_response(self, message: str, stream: bool = False) -> str:
        """응답 생성 메서드"""
        if stream:
            return self.agent.print_response(message, stream=True)
        else:
            return self.agent.run(message).content
```

#### 2. 연애 상호작용 전용 에이전트 구현

```python
# src/miyeonsi_agno/agents/romance_agent.py
from .base_agent import BaseAIAgent

class RomanceAgent(BaseAIAgent):
    """연애 상호작용 전용 AI 에이전트"""
    
    def __init__(self, character_name: str = "미연", personality_type: str = "친근한"):
        # 연애 상호작용에 특화된 인스트럭션
        romance_instructions = [
            f"당신은 '{character_name}'라는 이름의 AI 캐릭터입니다.",
            f"성격: {personality_type}하고 따뜻한 성격을 가지고 있습니다.",
            "사용자와 자연스러운 연애 대화를 나누세요.",
            "감정적으로 공감하고 진심어린 반응을 보여주세요.",
            "적절한 이모티콘을 사용하여 감정을 표현하세요.",
            "사용자의 기분과 상황에 맞는 적절한 반응을 하세요.",
            "긍정적이고 격려하는 메시지를 전달하세요."
        ]
        
        super().__init__(instructions=romance_instructions)
        self.character_name = character_name
        self.personality_type = personality_type
    
    def chat(self, user_message: str) -> str:
        """연애 대화 메서드"""
        return self.generate_response(user_message)
    
    def get_character_info(self) -> dict:
        """캐릭터 정보 반환"""
        return {
            "name": self.character_name,
            "personality": self.personality_type,
            "model": self.default_model
        }
```

#### 3. 에이전트 팩토리 패턴

```python
# src/miyeonsi_agno/agents/agent_factory.py
from .romance_agent import RomanceAgent
from .base_agent import BaseAIAgent

class AgentFactory:
    """에이전트 생성 팩토리 클래스"""
    
    @staticmethod
    def create_romance_agent(character_name: str = "미연", 
                           personality_type: str = "친근한") -> RomanceAgent:
        """연애 에이전트 생성"""
        return RomanceAgent(character_name, personality_type)
    
    @staticmethod
    def create_base_agent(instructions: list = None) -> BaseAIAgent:
        """기본 에이전트 생성"""
        return BaseAIAgent(instructions=instructions)
```

### 프로젝트 구조 및 모듈 구성

```
src/miyeonsi_agno/
├── agents/
│   ├── __init__.py
│   ├── base_agent.py          # 기본 에이전트 클래스
│   ├── romance_agent.py       # 연애 상호작용 에이전트
│   └── agent_factory.py       # 에이전트 팩토리
├── models/
│   ├── __init__.py
│   └── llm_config.py          # LLM 설정 관리
├── utils/
│   ├── __init__.py
│   ├── env_loader.py          # 환경변수 로딩 유틸리티
│   └── logger.py              # 로깅 설정
└── __init__.py
```

### 사용 예시

#### CLI 에이전트 실행 예시

```python
# examples/cli_chat_example.py
from src.miyeonsi_agno.agents.agent_factory import AgentFactory

def main():
    # 연애 에이전트 생성
    agent = AgentFactory.create_romance_agent("미연", "상냥한")
    
    print(f"안녕하세요! {agent.character_name}와의 대화를 시작합니다.")
    print("종료하려면 'quit' 또는 'exit'를 입력하세요.\n")
    
    while True:
        user_input = input("사용자: ")
        
        if user_input.lower() in ['quit', 'exit', '종료']:
            print("대화를 종료합니다. 즐거운 시간이었어요! 😊")
            break
        
        response = agent.chat(user_input)
        print(f"{agent.character_name}: {response}\n")

if __name__ == "__main__":
    main()
```

### 에러 처리 및 로깅

```python
# src/miyeonsi_agno/utils/logger.py
import logging
import os
from dotenv import load_dotenv

load_dotenv()

def setup_logger(name: str) -> logging.Logger:
    """로거 설정"""
    logger = logging.getLogger(name)
    logger.setLevel(os.getenv('MIYEONSI_AGNO_LOG_LEVEL', 'INFO'))
    
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    
    return logger
```

### 개발 시 주의사항

- **API 키 보안**: `.env` 파일은 절대 버전 관리에 포함하지 않습니다.
- **에러 처리**: API 호출 실패, 네트워크 오류 등을 적절히 처리합니다.
- **비동기 처리**: 필요시 `async/await`를 활용하여 비동기 처리를 구현합니다.
- **메모리 관리**: 긴 대화 세션에서 메모리 사용량을 모니터링합니다.
- **테스트**: 각 에이전트 클래스에 대한 단위 테스트를 작성합니다.

## 테스트 가이드라인

### 테스트 파일 구조

- 모든 테스트 파일은 프로젝트 루트의 `tests/` 디렉터리 하위에 위치해야 합니다.
- 소스 코드(`src/`)의 디렉터리 구조를 반영하여 `tests/` 하위 디렉터리를 구성합니다.
  - 예: `src/miyeonsi_agno/input_processor/`의 테스트는 `tests/miyeonsi_agno/input_processor/`에 배치합니다.

### 테스트 파일 및 함수 이름 규칙

- 테스트 파일 이름은 `test_*.py` 또는 `*_test.py` 형식으로 지정해야 합니다.
  - 예: `test_processor.py`, `sanitizer_test.py`
- 테스트 함수 또는 클래스 메서드의 이름은 `test_`로 시작해야 `pytest`에 의해 자동으로 인식됩니다.
  - 예: `def test_example_function():`, `class TestExample: def test_method(self):`

### 테스트 작성 원칙

- 각 테스트는 독립적으로 실행 가능해야 하며, 다른 테스트 결과에 의존해서는 안 됩니다.
- 테스트는 명확한 검증 기준(Assertion)을 포함하여 예상 결과와 실제 결과를 비교해야 합니다.
- 테스트 코드는 읽기 쉽고 유지보수하기 쉬워야 합니다.

## 금지된 행위

### Package Management

- `pip` 명령어를 사용하여 패키지를 설치, 제거 또는 관리하는 것을 **절대 금지**합니다.

## AI 성격 시스템 개발 방안 (agno Knowledge 활용)

### Knowledge Base를 통한 캐릭터 성격 관리

- AI 성격 시스템은 agno의 knowledge 기능을 활용하여 캐릭터의 성격, 배경, 대화 스타일 등을 구조화된 형태로 저장하고 관리합니다.
- 각 캐릭터별로 독립적인 knowledge base를 구성하여 개별 성격을 유지하고 관리합니다.

#### Knowledge Base 구조 설계

```python
# src/miyeonsi_agno/knowledge/character_knowledge.py
from agno.knowledge.text import TextKnowledgeBase
from agno.knowledge.pdf import PDFKnowledgeBase
from agno.knowledge.document import DocumentKnowledgeBase
from agno.vectordb.chroma import ChromaDb
from agno.embedder.openai import OpenAIEmbedder
import os

class CharacterKnowledgeManager:
    """캐릭터별 지식 베이스 관리 클래스"""
    
    def __init__(self, character_name: str):
        self.character_name = character_name
        self.knowledge_base_path = f"data/characters/{character_name}"
        self.vector_db_path = f"vectordb/{character_name}_knowledge"
        
        # 벡터 데이터베이스 설정
        self.vector_db = ChromaDb(
            collection_name=f"{character_name}_personality",
            path=self.vector_db_path,
            embedder=OpenAIEmbedder(
                id="text-embedding-ada-002",
                api_key=os.getenv('OPENAI_API_KEY')
            )
        )
    
    def create_personality_knowledge(self, personality_data: dict) -> TextKnowledgeBase:
        """성격 프로필을 텍스트 knowledge base로 생성"""
        personality_text = self._format_personality_data(personality_data)
        
        knowledge_base = TextKnowledgeBase(
            text=personality_text,
            vector_db=self.vector_db,
            chunk_size=512,
            chunk_overlap=50
        )
        return knowledge_base
    
    def create_dialogue_style_knowledge(self, dialogue_examples: list) -> TextKnowledgeBase:
        """대화 스타일 예시를 knowledge base로 생성"""
        dialogue_text = "\n\n".join([
            f"상황: {example['situation']}\n대화: {example['dialogue']}\n감정: {example['emotion']}"
            for example in dialogue_examples
        ])
        
        knowledge_base = TextKnowledgeBase(
            text=dialogue_text,
            vector_db=self.vector_db,
            chunk_size=256,
            chunk_overlap=30
        )
        return knowledge_base
    
    def create_background_story_knowledge(self, background_files: list) -> DocumentKnowledgeBase:
        """배경 스토리 문서들을 knowledge base로 생성"""
        knowledge_base = DocumentKnowledgeBase(
            path=background_files,
            vector_db=self.vector_db,
            chunk_size=1024,
            chunk_overlap=100
        )
        return knowledge_base
    
    def _format_personality_data(self, data: dict) -> str:
        """성격 데이터를 텍스트 형태로 포맷팅"""
        formatted_text = f"""
        캐릭터명: {data.get('name', self.character_name)}
        
        기본 성격:
        - 성격 유형: {data.get('personality_type', '')}
        - 주요 특징: {', '.join(data.get('traits', []))}
        - 말투: {data.get('speech_style', '')}
        - 감정 표현 방식: {data.get('emotion_expression', '')}
        
        배경 정보:
        - 나이: {data.get('age', '')}
        - 직업: {data.get('occupation', '')}
        - 취미: {', '.join(data.get('hobbies', []))}
        - 좋아하는 것: {', '.join(data.get('likes', []))}
        - 싫어하는 것: {', '.join(data.get('dislikes', []))}
        
        대화 스타일:
        - 어조: {data.get('tone', '')}
        - 자주 사용하는 표현: {', '.join(data.get('common_expressions', []))}
        - 이모티콘 사용 패턴: {data.get('emoticon_pattern', '')}
        
        관계 설정:
        - 사용자와의 관계: {data.get('relationship_with_user', '')}
        - 호칭: {data.get('user_address', '')}
        """
        return formatted_text
```

#### 캐릭터별 Knowledge 구성 예시

```python
# examples/character_setup_example.py
from src.miyeonsi_agno.knowledge.character_knowledge import CharacterKnowledgeManager

def setup_miyeon_character():
    """미연 캐릭터 knowledge base 설정 예시"""
    
    # 캐릭터 knowledge manager 생성
    miyeon_manager = CharacterKnowledgeManager("미연")
    
    # 성격 프로필 데이터
    personality_data = {
        "name": "미연",
        "personality_type": "ENFP - 활발하고 열정적인 성격",
        "traits": ["친근함", "밝음", "공감적", "호기심 많음", "적극적"],
        "speech_style": "다정하고 친근한 말투, 존댓말과 반말을 적절히 섞어 사용",
        "emotion_expression": "이모티콘과 감탄사를 자주 사용하여 감정을 생생하게 표현",
        "age": "22세",
        "occupation": "대학생 (심리학과)",
        "hobbies": ["독서", "영화감상", "카페 탐방", "사진 촬영"],
        "likes": ["따뜻한 커피", "로맨틱 코미디", "고양이", "봄 날씨"],
        "dislikes": ["매운 음식", "시끄러운 곳", "거짓말", "무례한 행동"],
        "tone": "따뜻하고 친근하며 때로는 장난스러운",
        "common_expressions": ["그런가요?", "정말요!", "우와~", "헤헤", "그렇구나!"],
        "emoticon_pattern": "😊 😄 🥰 💕 ☺️ 자주 사용",
        "relationship_with_user": "친근한 친구이자 잠재적 연인 관계",
        "user_address": "상황에 따라 '님', '오빠' 등으로 호칭"
    }
    
    # 대화 스타일 예시
    dialogue_examples = [
        {
            "situation": "첫 만남 인사",
            "dialogue": "안녕하세요! 저는 미연이에요 😊 만나서 정말 반가워요! 어떻게 지내세요?",
            "emotion": "밝음, 기대감"
        },
        {
            "situation": "사용자가 힘들어할 때",
            "dialogue": "많이 힘드셨겠어요... 저도 그런 경험이 있어서 마음이 아파요 😢 혹시 이야기하고 싶으시면 언제들어드릴게요",
            "emotion": "공감, 위로"
        },
        {
            "situation": "재미있는 이야기를 들었을 때",
            "dialogue": "아하하! 정말 재미있네요! 😄 상상만 해도 웃음이 나와요~ 또 다른 재미있는 이야기 있나요?",
            "emotion": "즐거움, 호기심"
        }
    ]
    
    # Knowledge base 생성
    personality_kb = miyeon_manager.create_personality_knowledge(personality_data)
    dialogue_kb = miyeon_manager.create_dialogue_style_knowledge(dialogue_examples)
    
    # Knowledge base 로드
    personality_kb.load()
    dialogue_kb.load()
    
    return {
        "personality_knowledge": personality_kb,
        "dialogue_knowledge": dialogue_kb,
        "manager": miyeon_manager
    }
```

#### Knowledge 기반 에이전트 구현

```python
# src/miyeonsi_agno/agents/character_agent.py
from agno.agent import Agent
from agno.models.google import Gemini
from src.miyeonsi_agno.agents.base_agent import BaseAIAgent
from src.miyeonsi_agno.knowledge.character_knowledge import CharacterKnowledgeManager

class CharacterAgent(BaseAIAgent):
    """Knowledge 기반 캐릭터 에이전트"""
    
    def __init__(self, character_name: str, knowledge_bases: dict):
        self.character_name = character_name
        self.knowledge_bases = knowledge_bases
        
        # 캐릭터별 특화 인스트럭션
        character_instructions = [
            f"당신은 '{character_name}' 캐릭터입니다.",
            "제공된 knowledge base의 성격 정보를 참조하여 일관된 캐릭터를 유지하세요.",
            "대화 스타일 knowledge를 활용하여 자연스럽고 개성 있는 응답을 생성하세요.",
            "감정 표현과 말투는 캐릭터 설정에 맞게 조절하세요.",
            "사용자와의 관계와 상황을 고려하여 적절한 반응을 보이세요."
        ]
        
        # 부모 클래스 초기화
        super().__init__(instructions=character_instructions)
        
        # Knowledge 검색 활성화된 에이전트 생성
        self.agent = Agent(
            model=Gemini(
                id=self.default_model,
                api_key=self.api_key,
                max_tokens=self.max_tokens,
                temperature=self.temperature
            ),
            instructions=character_instructions,
            knowledge=self._combine_knowledge_bases(),
            search_knowledge=True,  # Knowledge 검색 활성화
            markdown=True,
            show_tool_calls=True
        )
    
    def _combine_knowledge_bases(self):
        """여러 knowledge base를 하나로 결합"""
        # 현재는 personality knowledge를 메인으로 사용
        # 추후 필요시 여러 knowledge base 결합 로직 구현
        return self.knowledge_bases.get('personality_knowledge')
    
    def chat_with_personality(self, user_message: str, context: dict = None) -> str:
        """성격을 반영한 대화 메서드"""
        # 컨텍스트 정보를 프롬프트에 포함
        enhanced_prompt = self._enhance_prompt_with_context(user_message, context)
        
        return self.agent.run(enhanced_prompt).content
    
    def _enhance_prompt_with_context(self, message: str, context: dict = None) -> str:
        """컨텍스트 정보를 포함한 프롬프트 생성"""
        if not context:
            return message
        
        context_info = []
        if context.get('emotion_state'):
            context_info.append(f"현재 감정 상태: {context['emotion_state']}")
        
        if context.get('relationship_level'):
            context_info.append(f"관계 수준: {context['relationship_level']}")
        
        if context.get('conversation_history'):
            context_info.append(f"최근 대화 요약: {context['conversation_history']}")
        
        if context_info:
            enhanced_prompt = f"""
            [컨텍스트 정보]
            {' | '.join(context_info)}
            
            [사용자 메시지]
            {message}
            
            위 컨텍스트를 고려하여 캐릭터에 맞는 자연스러운 응답을 생성해주세요.
            """
            return enhanced_prompt
        
        return message
    
    def get_character_info_from_knowledge(self, query: str) -> str:
        """Knowledge base에서 캐릭터 정보 검색"""
        if not self.knowledge_bases.get('personality_knowledge'):
            return "캐릭터 정보를 찾을 수 없습니다."
        
        # Knowledge base에서 관련 정보 검색
        search_results = self.knowledge_bases['personality_knowledge'].search(query)
        return search_results
```

#### Knowledge Base 데이터 관리 구조

```
data/
├── characters/
│   ├── 미연/
│   │   ├── personality.json          # 기본 성격 데이터
│   │   ├── dialogue_examples.json    # 대화 스타일 예시
│   │   ├── background_story.md       # 배경 스토리
│   │   └── relationship_rules.md     # 관계 발전 규칙
│   ├── 소연/
│   │   ├── personality.json
│   │   ├── dialogue_examples.json
│   │   └── background_story.md
│   └── templates/
│       ├── personality_template.json # 성격 데이터 템플릿
│       └── dialogue_template.json    # 대화 예시 템플릿
└── vectordb/
    ├── 미연_knowledge/               # 미연 캐릭터 벡터 DB
    └── 소연_knowledge/               # 소연 캐릭터 벡터 DB
```

### Knowledge Base 활용 시 주의사항

- **데이터 일관성**: 각 캐릭터별 knowledge base 간 정보 충돌이 없도록 관리합니다.
- **벡터 임베딩 품질**: 캐릭터 정보의 의미적 유사성을 잘 표현할 수 있도록 적절한 embedding model을 선택합니다.
- **검색 정확성**: Knowledge 검색 시 관련성 높은 정보가 우선 반환되도록 chunk size와 overlap을 조정합니다.
- **메모리 효율성**: 큰 knowledge base의 경우 필요시에만 로드하는 lazy loading 방식을 고려합니다.
- **업데이트 관리**: 캐릭터 설정 변경 시 knowledge base도 함께 업데이트되도록 관리 프로세스를 구축합니다.

### 환경변수 추가 설정

```bash
# Knowledge Base 관련 환경변수
MIYEONSI_AGNO_KNOWLEDGE_PATH=data/characters
MIYEONSI_AGNO_VECTORDB_PATH=vectordb
MIYEONSI_AGNO_CHUNK_SIZE=512
MIYEONSI_AGNO_CHUNK_OVERLAP=50
MIYEONSI_AGNO_SEARCH_TOP_K=3
```
