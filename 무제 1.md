## 기술 구현 문서: 텍스트 CLI 기반 미연시 연애 시뮬레이션

### 1. 개요

본 문서는 텍스트 CLI 기반 미연시 연애 시뮬레이션 게임의 상세한 구현 설계를 다룹니다. PRD에서 정의된 요구사항을 바탕으로 각 모듈의 책임, 역할, 그리고 협력 관계를 정의하여 기능별 최적의 구현 방안을 제시합니다. 특히, 모듈 간의 낮은 의존성과 단일 책임 원칙을 준수하여 유연하고 확장 가능한 아키텍처를 목표로 합니다.

### 2. 아키텍처 개요

전체 시스템은 다음과 같은 주요 모듈로 구성됩니다.

코드 스니펫

```
graph TD
    UserInterface --> InputHandler
    InputHandler --> GameController
    GameController --> CharacterManager
    GameController --> DialogueManager
    GameController --> StoryManager
    GameController --> AffinityManager
    GameController --> SaveLoadManager
    CharacterManager --> KnowledgeBase
    DialogueManager --> CharacterManager
    DialogueManager --> StoryManager
    DialogueManager --> LLMAdapter
    StoryManager --> AffinityManager
    StoryManager --> EventSystem
    AffinityManager --> CharacterManager
```

### 3. 모듈별 상세 구현 설계

#### 3.1. `UserInterface` 모듈

- **책임**: 사용자에게 게임의 모든 텍스트 정보를 출력하고, 시각적으로 명확하게 구성하여 표시합니다.
- **역할**:
    - 캐릭터 대사, 상황 묘사, 선택지 등을 터미널에 출력합니다.
    - 현재 게임 상황, 캐릭터 정보, 선택지 등을 명확하게 구분하여 표시합니다.
    - 사용자 입력 프롬프트를 출력합니다.
- **협력**: `InputHandler` (사용자 입력 프롬프트 출력 후 입력 대기 지시)

#### 3.2. `InputHandler` 모듈

- **책임**: 사용자로부터 명령어를 입력받아 파싱하고, 유효성을 검증하여 `GameController`에 전달합니다.
- **역할**:
    - 사용자 입력을 대기하고 읽어들입니다.
    - 입력된 명령어를 분석하여 (`대화하기`, `선택지`, `상태보기` 등) 유효한 명령인지 확인합니다.
    - 명령어에 포함된 인자(예: 캐릭터 이름, 선택지 번호)를 추출합니다.
- **협력**: `UserInterface` (입력 프롬프트 출력 요청), `GameController` (파싱된 명령어 및 인자 전달)

#### 3.3. `GameController` 모듈

- **책임**: 게임의 전반적인 흐름을 제어하고, 각 서브 모듈 간의 상호작용을 조율합니다.
- **역할**:
    - 게임 시작, 종료, 메인 루프를 관리합니다.
    - `InputHandler`로부터 받은 명령어를 기반으로 적절한 서브 모듈의 기능을 호출합니다.
    - 게임 상태(예: 현재 진행 중인 스토리, 활성화된 캐릭터)를 관리합니다.
- **협력**: `InputHandler` (명령어 수신), `CharacterManager` (캐릭터 정보 요청/전달), `DialogueManager` (대화 시작 요청), `StoryManager` (스토리 진행 요청), `AffinityManager` (호감도 변경 요청), `SaveLoadManager` (저장/불러오기 요청)

#### 3.4. `CharacterManager` 모듈

- **책임**: 게임 내 모든 캐릭터의 생성, 관리 및 상태 정보를 유지합니다.
- **역할**:
    - 사전 정의된 캐릭터 템플릿(성격, 가치관, 배경 스토리)을 기반으로 캐릭터 객체를 생성합니다.
    - 각 캐릭터의 고유 지식 베이스(`KnowledgeBase`)를 로드하고 관리합니다.
    - 캐릭터의 현재 호감도, 감정 상태, 기억(선택적)과 같은 동적인 상태를 업데이트하고 제공합니다.
    - 새로운 캐릭터의 등장 조건을 관리합니다.
- **협력**: `KnowledgeBase` (캐릭터 지식 로드), `AffinityManager` (호감도 정보 제공), `DialogueManager` (캐릭터 정보 제공)

#### 3.5. `KnowledgeBase` 모듈

- **책임**: 각 캐릭터의 고유한 지식과 반응 패턴을 정의하고 제공합니다.
- **역할**:
    - 캐릭터별 지식 데이터(JSON 또는 파일)를 로드합니다.
    - 캐릭터별 맞춤형 프롬프트 템플릿을 제공합니다.
    - 특정 주제에 대한 캐릭터의 지식, 말투, 반응 패턴 데이터를 제공합니다.
- **협력**: `CharacterManager` (캐릭터 생성 시 지식 로드), `LLMAdapter` (대화 생성 시 프롬프트 및 지식 제공)

#### 3.6. `DialogueManager` 모듈

- **책임**: 사용자의 입력과 캐릭터의 정보를 기반으로 자연스러운 대화를 생성하고 관리합니다.
- **역할**:
    - 사용자의 입력(선택지 또는 키워드)을 처리합니다.
    - `CharacterManager`로부터 현재 대화 중인 캐릭터의 정보(성격, 감정 상태, 호감도)를 요청합니다.
    - `StoryManager`로부터 현재 스토리의 맥락 정보를 요청합니다.
    - `LLMAdapter`를 사용하여 대화 내용을 생성합니다.
    - 생성된 대화 내용과 다음 선택지를 `UserInterface`로 전달합니다.
- **협력**: `CharacterManager` (캐릭터 정보 획득), `StoryManager` (스토리 맥락 획득), `LLMAdapter` (대화 내용 생성 요청), `UserInterface` (대화 내용 및 선택지 출력 요청)

#### 3.7. `LLMAdapter` 모듈

- **책임**: 외부 LLM(Large Language Model) API와 통신하여 대화 텍스트를 생성합니다.
- **역할**:
    - `DialogueManager`로부터 전달받은 프롬프트, 캐릭터 지식, 대화 맥락을 기반으로 LLM API에 요청을 보냅니다.
    - LLM API의 응답을 파싱하여 대화 텍스트를 추출합니다.
    - API 오류 처리 및 재시도 로직을 포함합니다.
    - (선택적) 로컬 키워드 매칭 또는 규칙 기반 대화 생성 로직을 포함하여 LLM 호출을 최소화합니다.
- **협력**: `DialogueManager` (대화 생성 결과 반환), `KnowledgeBase` (대화 생성에 필요한 프롬프트 및 지식 요청)

#### 3.8. `StoryManager` 모듈

- **책임**: 게임의 스토리 흐름을 제어하고, 사용자의 선택과 캐릭터의 상태 변화에 따라 스토리를 분기하며 이벤트를 발생시킵니다.
- **역할**:
    - 현재 스토리의 진행 상황을 관리합니다.
    - `AffinityManager`로부터 캐릭터 호감도 변화를 감지하고 스토리 분기 조건을 판단합니다.
    - 이전 대화의 맥락이나 특정 조건을 기반으로 스토리를 유동적으로 전개합니다.
    - `EventSystem`을 통해 돌발 이벤트를 발생시킵니다.
    - 다양한 엔딩 조건 및 도달 로직을 관리합니다.
- **협력**: `AffinityManager` (호감도 정보 요청), `EventSystem` (이벤트 발생 요청), `DialogueManager` (스토리 맥락 제공)

#### 3.9. `EventSystem` 모듈

- **책임**: 게임 내에서 발생하는 돌발 이벤트를 관리하고 실행합니다.
- **역할**:
    - 현재 게임 상태, 캐릭터 상태, 스토리 진행 상황에 따라 확률적으로 이벤트 발생 여부를 결정합니다.
    - 이벤트 발생 시 필요한 정보(이벤트 내용, 선택지, 결과)를 `StoryManager`에 전달합니다.
    - 이벤트 선택에 따른 게임 상태 변화(호감도, 아이템 획득 등)를 `GameController` 또는 관련 모듈에 요청합니다.
- **협력**: `StoryManager` (이벤트 발생 요청 및 결과 전달)

#### 3.10. `AffinityManager` 모듈

- **책임**: 캐릭터별 호감도를 계산하고, 호감도 변화에 따른 로직을 처리합니다.
- **역할**:
    - 대화 내용, 선택, 선물 등의 상호작용에 따라 캐릭터별 호감도를 증감시킵니다.
    - 특정 호감도 임계점(Threshold)에 도달했을 때 `StoryManager`에 알림을 보냅니다.
    - 사용자가 특정 캐릭터의 호감도를 조회할 수 있는 기능을 제공합니다.
- **협력**: `GameController` (호감도 변경 요청), `StoryManager` (호감도 정보 제공 및 변경 알림), `CharacterManager` (캐릭터별 호감도 저장/조회)

#### 3.11. `SaveLoadManager` 모듈

- **책임**: 현재 게임 진행 상황을 저장하고 불러오는 기능을 제공합니다.
- **역할**:
    - 게임 상태(스토리 진행도, 캐릭터 호감도, 보유 아이템 등)를 직렬화하여 파일 시스템 또는 경량 데이터베이스(SQLite, JSON)에 저장합니다.
    - 저장된 게임 데이터를 읽어와 게임 상태를 복원합니다.
    - 여러 저장 슬롯 또는 사용자 프로필을 관리합니다 (선택적).
- **협력**: `GameController` (저장/불러오기 요청), `CharacterManager`, `StoryManager`, `AffinityManager` 등 (데이터 요청 및 업데이트)

### 4. 기술 스택 (PRD 기반)

- **프로그래밍 언어**: Python
- **데이터 저장**: JSON (캐릭터 데이터, 스토리 분기 데이터, 저장 데이터), SQLite (선택적, 복잡한 데이터 관리 시)
- **자연어 처리**:
    - 기본: 키워드 매칭, 정규 표현식 (초기 버전)
    - 고급: LLM API 연동 (OpenAI GPT, Google Gemini 등)
- **CLI UI**: `rich`, `curses` (선택적, 더 풍부한 UI 구현 시)

### 5. 추가 고려사항

- **에러 핸들링**: 각 모듈에서 발생할 수 있는 예외 상황(파일 입출력 오류, LLM API 통신 오류, 사용자 입력 오류 등)에 대한 명확한 에러 처리 전략을 수립합니다.
- **로깅**: 개발 및 디버깅을 위해 각 모듈의 주요 동작 및 상태 변화를 기록하는 로깅 시스템을 구축합니다.
- **테스트**: 각 모듈에 대한 단위 테스트 및 통합 테스트를 작성하여 기능의 정확성과 안정성을 확보합니다.
- **확장성**: 새로운 캐릭터, 스토리, 이벤트 추가가 용이하도록 데이터 기반의 설계를 지향합니다.
- **성능**: LLM API 호출 최소화 및 효율적인 데이터 관리로 CLI 환경에서의 응답 속도를 최적화합니다.