# 리팩토링 지침

## 1. 함수 및 메서드 분리

### 1-1. 10줄 이하로 제한

- 모든 함수와 메서드는 반드시 **10줄 이하**로 작성해야 합니다. 긴 라인의 구현 함수와 메서드는 가독성을 해칩니다.

### 1-2. 하나의 작업만을 수행

- 함수와 메서드는 **단일 책임 원칙**을 준수해야 합니다. 메서드나 함수가 여러 책임과 구현을 가지면 분리합니다.

### 1-3. 변수 유효 범위를 제한하기

- 함수 또는 메서드 스코프 내에서 전역처럼 쓰이는 변수는 지양해야 합니다. 유효범위가 너무 넓은 변수는 가독성과 유지보수성을 저하시키고, 의도하지 않은 부작용을 유발하기 때문이다.

#### 예시
**리팩토링 전:**
```python
def process_numbers(numbers):
    result = []  # 결과를 저장할 리스트
    temp = None  # 중간 상태를 저장하는 변수

    # 첫 번째 처리 단계
    for number in numbers:
        if number % 2 == 0:
            temp = number * 2  # 짝수는 두 배로
        else:
            temp = number + 1  # 홀수는 +1
        result.append(temp)

    # 두 번째 처리 단계: 다시 temp를 사용
    for i in range(len(result)):
        temp = result[i] + 5  # 모든 값을 +5
        result[i] = temp

    # 세 번째 처리 단계: temp를 다시 사용
    temp = sum(result)  # 합산
    if temp > 100:
        result = [x - 10 for x in result]  # 값이 100을 넘으면 -10

    return result

numbers = [1, 2, 3, 4, 5]
print(process_numbers(numbers))  # 결과는 예상하기 어려움

```

**문제점 분석:**
- result와 temp가 여러번 업데이트되고 마치 전역 변수처럼 쓰임
- temp 변수가 중간에 계속 수정되면서 결과를 예측하기 어려워지고, 디버깅이 어려워짐.

**리팩토링 후:**
```python
def process_numbers(numbers):
    # 첫 번째 처리 단계: 홀수/짝수 구분 처리
    processed_step1 = [
        number * 2 if number % 2 == 0 else number + 1
        for number in numbers
    ]

    # 두 번째 처리 단계: 모든 값에 +5
    processed_step2 = [x + 5 for x in processed_step1]

    # 세 번째 처리 단계: 합산 기준으로 처리
    total = sum(processed_step2)
    if total > 100:
        final_result = [x - 10 for x in processed_step2]
    else:
        final_result = processed_step2

    return final_result

numbers = [1, 2, 3, 4, 5]
print(process_numbers(numbers))  # 결과를 쉽게 이해할 수 있음
```

**개선점 분석:**
- 중간 상태 변수들이 processed_step1, processed_step2, final_result로 관리되기 때문에 각 변수가 하나의 책임을 가지고 쉽게 이해가 가능함.

---

## 2. 조건문 사용 규칙
- 중첩된 `if` 문은 **사용하지 않습니다**. 모든 조건문은 평탄화(flatten)해야 합니다.
- `else` 문은 **사용하지 않습니다**. 대신 조건문을 재구성합니다.

### 예시
**리팩토링 전:**
```python
def classify_number(num):
    if num > 0:
        if num % 2 == 0:
            return "Positive Even"
        else:
            return "Positive Odd"
    else:
        return "Non-positive"
```

**문제점 분석:**
-` if`문의 중첩으로 분기에 대한 이해가 힘들어진다.
- `else`의 사용은 `if` 외의 모든 분기 조건이지만, 이것에 대해 이해가 힘들어진다.

**리팩토링 후:**
```python
def classify_number(num):
    """Classify the number as positive even, positive odd, or non-positive."""
    if num <= 0:
        return "Non-positive"
    if num % 2 == 0:
        return "Positive Even"
    return "Positive Odd"
```

**개선점 분석:**
- `if`문을 평탄화해서 한단계에서만 사용하기 때문에 가독성이 높아졌다.
- `else`을 사용하지 않고도 코드를 이해하기 쉽고 가독성이 높아졌다.

## 3. 클로저 금지
- 함수 내부에서 다른 함수를 정의하지 않습니다.
- 모든 헬퍼 함수는 **독립적인 전역 함수** 또는 **클래스 메서드**로 작성합니다.

### 예시
**리팩토링 전:**
```python
def calculate_total(data):
    def is_valid(item):
        return item > 0
    return sum(item for item in data if is_valid(item))
```

**문제점 분석:**
- 클로저는 매우 강력한 문법중 하나지만, 다른 언어를 하고 온 사람들은 이해하기 쉽지 않을 수 있고, 스코프에 따른 변수의 life Cycle에 대해서 한번 더 고민해야하기 때문에 협업이 어려워질 수 있다. 그래서 클로저 문법은 지양해야한다.

**리팩토링 후:**
```python
def is_valid_item(item):
    return item > 0

def calculate_total(data):
    return sum(item for item in data if is_valid_item(item))
```

**개선점 분석:**
- 클로저를 사용하지 않음으로써, 조금 더 쉽게 함수들의 각 관계에 대해서 이해할 수 있게 되었다.

---

## 4. 로직 분리 및 모듈화
- 코드가 길거나 복잡할 경우, 관련 기능을 **독립적인 함수/클래스**로 분리합니다.
- 동일한 작업을 반복적으로 수행하는 경우, 재사용 가능한 **헬퍼 함수**를 작성합니다.

## 5. 스타일 가이드 준수
- [PEP 8](https://peps.python.org/pep-0008/) 스타일 가이드를 준수합니다.
- 각 함수와 클래스에는 간결한 **docstring**을 추가합니다.

### 예시

**리팩토링 전:**
```python
def add_numbers(a, b):
    return a + b

class Calculator:
    def multiply(self, x, y):
        return x * y

```

**문제점 분석:**
- 코드를 직접 봐야 코드의 내용을 알 수 있음.
- 코드 분석에 시간을 투자해야 함.
- 매개변수 제약조건과 기대되는 타입에 대해 이해하기 어렵고 다른 사람들이 사용하기 쉽지 않음.

**리팩토링 후:**
```python
def add_numbers(a: int, b: int) -> int:
    """
    두 정수를 더한 값을 반환합니다.

    Args:
        a (int): 첫 번째 정수.
        b (int): 두 번째 정수.

    Returns:
        int: 두 정수의 합.
    """
    return a + b

class Calculator:
    """
    간단한 산술 연산을 수행하는 계산기 클래스.
    """

    def multiply(self, x: int, y: int) -> int:
        """
        두 정수를 곱한 값을 반환합니다.

        Args:
            x (int): 첫 번째 정수.
            y (int): 두 번째 정수.

        Returns:
            int: 두 정수의 곱.
        """
        return x * y

```

**개선점 분석:**

- 가독성 향상
- 유지 보수 용이
- 자동화된 도구 문서와 통합이 쉽고, 다른 개발자에게 쉽게 사용가이드를 제공할 수 있다
