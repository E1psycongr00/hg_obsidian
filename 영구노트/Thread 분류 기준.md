---
tags:
  - 완성
  - OS
  - Thread
aliases: 
date: 2024-12-09
title: Thread 분류 기준
---
작성 날짜: 2024-12-09
작성 시간: 12:52


----
## 내용(Content)

### 쓰레드 분류 기준

[[Thread Basic#^40241b|쓰레드]]는 분류하면 크게 하드웨어와 소프트웨어 분류 방법과 관리 주체에 따른 분류로 나눌 수 있다.


### Hardware vs Software

병렬로 무엇인가 실행한다는 의미는 같지만 적용되는 대상이 다르다. CPU 쓰레드의 경우 보통 CPU의 논리적인 최소 처리 단위를 의미하고, 소프트웨어의 경우 application 또는 OS 레벨에서 관리되는 논리적인 처리 단위이다. 대상이 다르기 떄문에 쓰레드 스케줄링의 주체도 다르다.

| 구분        | CPU 쓰레드                             | 소프트웨어 쓰레드                 |
| --------- | ----------------------------------- | ------------------------- |
| **의미**    | 하드웨어가 병렬로 처리할 수 있는 작업 단위.           | 소프트웨어에서 실행되는 병렬 실행 단위.    |
| **제어 주체** | CPU 하드웨어 및 펌웨어.                     | 운영 체제 또는 애플리케이션 레벨에서 제어.  |
| **구현 방식** | CPU 내부 레지스터, ALU 등 물리적 자원 활용.       | 메모리 및 운영 체제의 커널 스케줄링 이용.  |
| **병렬 처리** | 하드웨어 수준의 병렬 처리 능력.                  | 소프트웨어 수준의 병렬 작업 지원.       |
| **스케줄링**  | CPU가 하드웨어적으로 처리 가능.                 | 운영 체제 커널 또는 사용자 수준에서 관리.  |
| **예**     | 4코어 8쓰레드 CPU(물리적 코어 4개, 하이퍼스레딩 2개). | Java 쓰레드, POSIX Pthreads. |

### Kenel vs User

쓰레드의 관리 주체와 실행 방식에 따라 구분되고, 서로 간의 장단점이 존재한다.

|**기준**|**커널 수준 쓰레드 (Kernel-Level Thread)**|**사용자 수준 쓰레드 (User-Level Thread)**|
|---|---|---|
|**관리 주체**|운영 체제의 커널에서 직접 관리.|애플리케이션 또는 사용자 라이브러리에서 관리.|
|**스케줄링**|커널이 각 쓰레드를 독립적으로 스케줄링.|애플리케이션 내에서 사용자 정의 스케줄링 수행.|
|**블로킹 문제**|하나의 쓰레드가 블로킹되어도 다른 쓰레드에 영향을 주지 않음.|하나의 쓰레드가 블로킹되면 전체 프로세스가 블로킹될 수 있음.|
|**컨텍스트 스위칭 비용**|커널 모드 전환이 필요하므로 상대적으로 비용이 높음.|사용자 공간에서만 동작하므로 비용이 낮음.|
|**운영 체제의 인식**|쓰레드마다 커널에 의해 독립적으로 인식되고 관리됨.|운영 체제는 프로세스 단위로만 관리하며, 개별 쓰레드는 인식하지 않음.|
|**병렬 처리**|멀티코어 CPU에서 실제 병렬 실행 가능.|커널 쓰레드가 병렬 처리를 지원하지 않으면, 실제 병렬 실행 불가능.|
|**이식성**|운영 체제 종속적.|운영 체제와 독립적이며 이식성이 높음.|
|**설계 복잡성**|운영 체제가 복잡한 구현과 관리를 요구함.|애플리케이션 수준에서 구현되므로 단순한 설계 가능.|
|**예시**|리눅스의 기본 쓰레드, Windows의 Win32 쓰레드.|POSIX Pthreads(유저 모드), Java Green Threads.|


## 질문 & 확장

(없음)

## 출처(링크)


## 연결 노트

- element:: [[CPU 쓰레드(Thread)|하드웨어 쓰레드]]
- element:: [[User Level Thread|User Level Thread]]
- element:: [[OS 쓰레드|Kernel Level Thread]]









