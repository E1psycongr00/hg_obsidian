# 책임 주도 설계(RDD) 실무 가이드

프로젝트 구현에 앞서, 특히 로직 및 백엔드 설계 시에는 **책임 주도 설계(Responsibility-Driven Design, RDD)** 원칙을 적극적으로 적용해야 합니다.

## 책임 주도 설계란?

RDD는 각 객체가 시스템 내에서 어떤 명확한 책임을 가질지 정의하는 데 중점을 둡니다. 이는 단순히 데이터와 메서드를 묶는 것을 넘어, **"누가 무엇을 알고, 누가 무엇을 해야 하는가?"**를 명확히 정의하는 설계 방법론입니다.

### 핵심 이점
- **높은 응집도 및 낮은 결합도**: 각 객체가 단일하고 명확한 책임을 가지게 되어 코드의 응집도가 높아지고, 불필요한 의존성을 줄여 결합도를 낮춥니다.
- **유지보수 및 확장 용이성**: 책임이 명확한 객체는 변경에 유연하게 대응할 수 있으며, 새로운 기능 추가 시 기존 코드의 변경 없이 확장하기 용이합니다.
- **시스템 이해도 증진**: 각 객체의 역할이 명확해지면서 시스템 전체의 동작 방식과 흐름을 더 쉽게 이해할 수 있습니다.

## RDD 적용 5단계 프로세스

### 1단계: 시스템 시나리오 분석
새로운 기능을 개발하기 전에 다음 질문들을 통해 시나리오를 분석합니다:
- **무엇이 시작점인가?** (사용자 액션, 외부 이벤트, 스케줄링 등)
- **어떤 정보가 필요한가?** (입력 데이터, 저장된 데이터, 외부 API 등)
- **어떤 작업들이 수행되어야 하는가?** (검증, 변환, 계산, 저장 등)
- **최종 결과는 무엇인가?** (응답 데이터, 상태 변경, 알림 등)

### 2단계: 책임 식별 및 분류
각 작업에 대해 **두 가지 유형의 책임**을 식별합니다:

#### 지식 책임 (Knowing Responsibilities)
- **데이터 보관**: 어떤 객체가 특정 정보를 저장하고 관리하는가?
- **계산 수행**: 어떤 객체가 특정 알고리즘이나 비즈니스 규칙을 알고 있는가?
- **상태 추적**: 어떤 객체가 시스템의 특정 상태를 모니터링하는가?

#### 행동 책임 (Doing Responsibilities)
- **작업 수행**: 어떤 객체가 실제 비즈니스 로직을 실행하는가?
- **다른 객체 제어**: 어떤 객체가 다른 객체들의 협력을 조정하는가?
- **외부 통신**: 어떤 객체가 외부 시스템과의 소통을 담당하는가?

### 3단계: CRC 카드 작성
각 식별된 객체에 대해 **클래스(Class), 책임(Responsibility), 역할(Roles), 협력자(Collaborators)** 정보를 정리합니다:

#### 책임과 역할의 구분
- **책임(Responsibility)**: 객체의 존재 이유를 한 문장으로 정의
- **역할(Roles)**: 책임을 달성하기 위한 구체적인 행동들

```
클래스명: UserAuthenticationManager
책임: 사용자 인증 프로세스 전반을 관리한다
역할:
  - 로그인 요청 검증
  - 인증 토큰 생성 및 검증
  - 세션 관리
  - 실패한 인증 시도 추적
협력자:
  - UserRepository (사용자 정보 조회)
  - TokenGenerator (JWT 토큰 생성)
  - SessionStore (세션 저장소)
  - SecurityLogger (보안 이벤트 로깅)
```

#### 클래스명 작성 가이드라인

**1. 책임 기반 명명**
- 클래스가 수행하는 주요 책임을 이름에 반영
- 좋은 예: `OrderProcessor`, `PaymentValidator`, `EmailNotificationSender`
- 나쁜 예: `UserService`, `DataManager`, `Helper`

**2. 구체적이고 명확한 이름**
- 추상적이거나 모호한 이름 지양
- 좋은 예: `PriceCalculator` → 가격 계산을 담당
- 나쁜 예: `BusinessLogic` → 무엇을 하는지 불분명

**3. 패턴별 명명 규칙**
- **Service 계층**: `[도메인][행동]Service` (예: `UserAuthenticationService`)
- **Repository 계층**: `[엔티티]Repository` (예: `OrderRepository`)
- **Manager 계층**: `[관리대상]Manager` (예: `ConnectionManager`)
- **Processor 계층**: `[처리대상]Processor` (예: `ImageProcessor`)
- **Validator 계층**: `[검증대상]Validator` (예: `EmailValidator`)
- **Factory 계층**: `[생성객체]Factory` (예: `DatabaseConnectionFactory`)

**4. 지양해야 할 이름 패턴**
- 범용적 이름: `Service`, `Manager`, `Handler`, `Util`
- 기술적 이름: `Controller`, `Bean`, `Component` (순수 비즈니스 로직에서)
- 모호한 이름: `Helper`, `Common`, `Base`

### 4단계: 협력 관계 설계
객체 간의 메시지 전달 패턴을 정의합니다:
- **누가 누구에게 무엇을 요청하는가?**
- **응답으로 무엇을 받아야 하는가?**
- **협력의 순서는 어떻게 되는가?**

### 5단계: 책임 검증 및 조정
설계된 책임이 다음 원칙들을 만족하는지 검증합니다:

#### 단일 책임 원칙 (SRP) 검증
- 각 객체의 책임을 한 문장으로 설명할 수 있는가?
- 객체가 변경되는 이유가 단 하나뿐인가?
- 객체의 모든 역할이 하나의 책임을 달성하는데 필요한가?

#### 의존성 방향 검증
- 고수준 모듈이 저수준 모듈에 의존하지 않는가?
- 순환 의존성이 존재하지 않는가?

## 구체적 적용 예시

### 좋은 RDD 설계 예시
```python
# 책임이 명확히 분리된 설계
class OrderCreationService:
    """주문 생성 프로세스를 관리한다"""
    def __init__(self, inventory_checker, payment_processor, order_repository):
        self._inventory_checker = inventory_checker
        self._payment_processor = payment_processor
        self._order_repository = order_repository
    
    def create_order(self, order_request):
        # 역할 1: 재고 확인
        self._inventory_checker.verify_availability(order_request.items)
        
        # 역할 2: 주문 엔티티 생성
        order = Order.from_request(order_request)
        
        # 역할 3: 결제 처리 조정
        payment_result = self._payment_processor.process_payment(
            order.total_amount, order_request.payment_info
        )
        
        # 역할 4: 주문 저장
        order.confirm_payment(payment_result)
        return self._order_repository.save(order)

class InventoryAvailabilityChecker:
    """상품 재고 가용성을 검증한다"""
    def verify_availability(self, items):
        # 단일 책임: 재고 확인만 담당
        pass

class PaymentTransactionProcessor:
    """결제 트랜잭션을 처리한다"""
    def process_payment(self, amount, payment_info):
        # 단일 책임: 결제 처리만 담당
        pass
```

### 피해야 할 안티패턴
```python
# 책임이 뒤섞인 잘못된 설계
class OrderService:  # 모호한 이름 + God Object
    """사용자 주문 관련 모든 것을 처리한다""" # 책임이 불분명
    
    def create_order(self, order_data):
        # 데이터베이스 직접 접근 (데이터 계층 책임 침범)
        cursor.execute("SELECT stock FROM inventory WHERE...")
        
        # 비즈니스 로직과 인프라 로직이 뒤섞임
        if stock < requested_quantity:
            # 알림 발송 로직 (알림 계층 책임 침범)
            smtp.send_mail("재고 부족", user.email)
            raise InsufficientStockError()
        
        # 결제 처리 로직 직접 구현 (결제 계층 책임 침범)
        payment_response = requests.post("https://payment-api.com/charge", {
            "amount": total_amount,
            "card_number": order_data.card_number
        })
        
        # 여러 책임이 한 클래스에 뒤섞여 있음
```

## 적용 체크리스트

### 설계 완료 후 검증 항목
- [ ] 각 클래스의 책임을 한 문장으로 설명할 수 있는가?
- [ ] 클래스명이 그 책임을 명확히 나타내는가?
- [ ] 한 클래스가 변경되는 이유가 하나뿐인가?
- [ ] 객체 간 협력 관계가 명확히 정의되었는가?
- [ ] 순환 의존성이 존재하지 않는가?
- [ ] 각 역할이 해당 객체의 책임 범위 내에 있는가?

### 코드 리뷰 시 점검 사항
- [ ] 새로운 기능 추가 시 기존 코드 수정이 최소화되는가?
- [ ] 테스트 작성이 용이한 구조인가?
- [ ] 각 객체를 독립적으로 이해할 수 있는가?
- [ ] 의존성 주입이 적절히 활용되고 있는가?
- [ ] 클래스명만 보고도 역할을 추측할 수 있는가?

### 클래스명 검증 체크리스트
- [ ] 이름만 보고도 무엇을 하는 클래스인지 알 수 있는가?
- [ ] Service, Manager, Helper 같은 모호한 접미사를 피했는가?
- [ ] 책임을 반영하는 동사나 명사를 포함하고 있는가?
- [ ] 팀 내 명명 규칙을 일관되게 적용했는가?

## 적용 범위 및 우선순위

### 최우선 적용 대상
- **비즈니스 로직 레이어**: 도메인 서비스, 엔티티, 값 객체
- **애플리케이션 서비스**: 유스케이스 조정 및 트랜잭션 관리
- **데이터 접근 레이어**: Repository, DAO 패턴

### 차순위 적용 대상
- **API 컨트롤러**: 요청/응답 처리 및 서비스 레이어 호출
- **외부 통합**: 외부 API 클라이언트, 메시지 큐 처리

### 상황에 따른 적용
- **UI 컴포넌트**: 복잡한 상태 관리가 필요한 경우에만 적용
- **유틸리티 클래스**: 단순한 도구성 함수는 RDD 적용 불필요

## 팀 내 실천 방법

1. **설계 리뷰 미팅**: 구현 전 30분간 책임 분배 논의
2. **CRC 카드 작성**: 복잡한 기능의 경우 필수적으로 작성
3. **네이밍 리뷰**: 클래스명이 책임을 적절히 반영하는지 검토
4. **페어 프로그래밍**: 구현 중 책임 분배에 대한 지속적 논의
5. **리팩터링 주기**: 월 1회 기존 코드의 책임 분배 검토

---

**기억하세요**: RDD는 완벽한 설계를 한 번에 만들어내는 것이 아니라, 지속적인 개선을 통해 더 나은 책임 분배를 찾아가는 과정입니다. 특히 **좋은 클래스명은 설계 의도를 명확히 전달하는 첫 번째 단계**입니다.



