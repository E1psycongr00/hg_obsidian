# 책임 주도 설계(RDD) 실무 가이드

프로젝트 구현에 앞서, 특히 로직 및 백엔드 설계 시에는 **책임 주도 설계(Responsibility-Driven Design, RDD)** 원칙을 적극적으로 적용해야 합니다.

## 책임 주도 설계란?

RDD는 각 객체가 시스템 내에서 어떤 명확한 책임을 가질지 정의하는 데 중점을 둡니다. 이는 단순히 데이터와 메서드를 묶는 것을 넘어, **"누가 무엇을 알고, 누가 무엇을 해야 하는가?"**를 명확히 정의하는 설계 방법론입니다.

### 핵심 이점
- **높은 응집도 및 낮은 결합도**: 각 객체가 단일하고 명확한 책임을 가지게 되어 코드의 응집도가 높아지고, 불필요한 의존성을 줄여 결합도를 낮춥니다.
- **유지보수 및 확장 용이성**: 책임이 명확한 객체는 변경에 유연하게 대응할 수 있으며, 새로운 기능 추가 시 기존 코드의 변경 없이 확장하기 용이합니다.
- **시스템 이해도 증진**: 각 객체의 역할이 명확해지면서 시스템 전체의 동작 방식과 흐름을 더 쉽게 이해할 수 있습니다.

## RDD 적용 5단계 프로세스

### 1단계: 시스템 시나리오 분석
새로운 기능을 개발하기 전에 다음 질문들을 통해 시나리오를 분석합니다:
- **무엇이 시작점인가?** (사용자 액션, 외부 이벤트, 스케줄링 등)
- **어떤 정보가 필요한가?** (입력 데이터, 저장된 데이터, 외부 API 등)
- **어떤 작업들이 수행되어야 하는가?** (검증, 변환, 계산, 저장 등)
- **최종 결과는 무엇인가?** (응답 데이터, 상태 변경, 알림 등)

### 2단계: 책임 식별 및 분류
각 작업에 대해 **두 가지 유형의 책임**을 식별합니다:

#### 지식 책임 (Knowing Responsibilities)
- **데이터 보관**: 어떤 객체가 특정 정보를 저장하고 관리하는가?
- **계산 수행**: 어떤 객체가 특정 알고리즘이나 비즈니스 규칙을 알고 있는가?
- **상태 추적**: 어떤 객체가 시스템의 특정 상태를 모니터링하는가?

#### 행동 책임 (Doing Responsibilities)
- **작업 수행**: 어떤 객체가 실제 비즈니스 로직을 실행하는가?
- **다른 객체 제어**: 어떤 객체가 다른 객체들의 협력을 조정하는가?
- **외부 통신**: 어떤 객체가 외부 시스템과의 소통을 담당하는가?

### 3단계: CRC 카드 작성
각 식별된 객체에 대해 다음 정보를 정리합니다:

```
클래스명: UserService
책임:
  - 사용자 인증 정보 검증
  - 사용자 프로필 데이터 관리
  - 비밀번호 정책 적용
협력자:
  - AuthRepository (사용자 인증 데이터 조회)
  - EmailService (인증 메일 발송)
  - PasswordValidator (비밀번호 규칙 검증)
```

### 4단계: 협력 관계 설계
객체 간의 메시지 전달 패턴을 정의합니다:
- **누가 누구에게 무엇을 요청하는가?**
- **응답으로 무엇을 받아야 하는가?**
- **협력의 순서는 어떻게 되는가?**

### 5단계: 책임 검증 및 조정
설계된 책임이 다음 원칙들을 만족하는지 검증합니다:

#### 단일 책임 원칙 (SRP) 검증
- 각 객체가 변경되는 이유가 단 하나인가?
- 객체의 모든 메서드가 하나의 응집된 목적을 가지는가?

#### 의존성 방향 검증
- 고수준 모듈이 저수준 모듈에 의존하지 않는가?
- 순환 의존성이 존재하지 않는가?

## 구체적 적용 예시

### 좋은 RDD 설계 예시
```python
# 책임이 명확히 분리된 설계
class OrderService:
    """주문 비즈니스 로직을 담당"""
    def __init__(self, order_repo, inventory_service, payment_service):
        self._order_repo = order_repo
        self._inventory = inventory_service
        self._payment = payment_service
    
    def create_order(self, order_data):
        # 1. 재고 확인 (InventoryService에 위임)
        if not self._inventory.check_availability(order_data.items):
            raise InsufficientStockError()
        
        # 2. 주문 생성 (자신의 핵심 책임)
        order = Order.create(order_data)
        
        # 3. 결제 처리 (PaymentService에 위임)
        payment_result = self._payment.process(order.total_amount)
        
        # 4. 주문 저장 (Repository에 위임)
        return self._order_repo.save(order)

class InventoryService:
    """재고 관리 전담"""
    def check_availability(self, items): pass
    def reserve_items(self, items): pass

class PaymentService:
    """결제 처리 전담"""
    def process(self, amount): pass
```

### 피해야 할 안티패턴
```python
# 책임이 뒤섞인 잘못된 설계
class OrderManager:  # 너무 많은 책임을 가진 God Object
    def create_order(self, order_data):
        # 데이터베이스 직접 접근
        cursor.execute("SELECT * FROM inventory WHERE...")
        
        # 비즈니스 로직과 데이터 접근 로직이 뒤섞임
        if stock < requested_quantity:
            # 이메일 발송 로직까지 포함
            smtp.send_mail("재고 부족 알림...")
        
        # 결제 처리 로직까지 직접 구현
        payment_api_response = requests.post(...)
```

## 적용 체크리스트

### 설계 완료 후 검증 항목
- [ ] 각 클래스의 책임을 한 문장으로 설명할 수 있는가?
- [ ] 클래스명이 그 책임을 명확히 나타내는가?
- [ ] 한 클래스가 변경되는 이유가 하나뿐인가?
- [ ] 객체 간 협력 관계가 명확히 정의되었는가?
- [ ] 순환 의존성이 존재하지 않는가?
- [ ] 각 메서드가 해당 객체의 책임 범위 내에 있는가?

### 코드 리뷰 시 점검 사항
- [ ] 새로운 기능 추가 시 기존 코드 수정이 최소화되는가?
- [ ] 테스트 작성이 용이한 구조인가?
- [ ] 각 객체를 독립적으로 이해할 수 있는가?
- [ ] 의존성 주입이 적절히 활용되고 있는가?

## 적용 범위 및 우선순위

### 최우선 적용 대상
- **비즈니스 로직 레이어**: 도메인 서비스, 엔티티, 값 객체
- **애플리케이션 서비스**: 유스케이스 조정 및 트랜잭션 관리
- **데이터 접근 레이어**: Repository, DAO 패턴

### 차순위 적용 대상
- **API 컨트롤러**: 요청/응답 처리 및 서비스 레이어 호출
- **외부 통합**: 외부 API 클라이언트, 메시지 큐 처리

### 상황에 따른 적용
- **UI 컴포넌트**: 복잡한 상태 관리가 필요한 경우에만 적용
- **유틸리티 클래스**: 단순한 도구성 함수는 RDD 적용 불필요

## 팀 내 실천 방법

1. **설계 리뷰 미팅**: 구현 전 30분간 책임 분배 논의
2. **CRC 카드 작성**: 복잡한 기능의 경우 필수적으로 작성
3. **페어 프로그래밍**: 구현 중 책임 분배에 대한 지속적 논의
4. **리팩터링 주기**: 월 1회 기존 코드의 책임 분배 검토

---

**기억하세요**: RDD는 완벽한 설계를 한 번에 만들어내는 것이 아니라, 지속적인 개선을 통해 더 나은 책임 분배를 찾아가는 과정입니다.


