---
tags:
aliases: 
created: 2025-05-02
title: 📚 서브 클래싱과 서브 타이핑 (오브젝트 - 조용호)
note-type: REF
from: Book
---

## 출처
- $ 오브젝트 - 코드로 이해하는 객체 지향 설계 by 조용호: p.435 ~ p.469
## 요약

## 추가 인용
>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p435
>상속의 첫 번째 용도는 **타입 계층**을 구현하는 것이다. 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다. 타입 계층의 관점에서 부모 클래스는 자식 클래스의 **일반화(generalization)**이고 자식 클래스는 부모 클래스의 **특수화(specialization)**이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p435
>상속의 두 번째 용도는 **코드 재사용**이다. 상속은 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있는 마법의 주문과도 같다. 상속을 사용하면 점진적으로 애플리케이션의 기능을 확장할 수 있다. 하지만 재사용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률이 크다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, 435
>동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다. 상속의 가치는 이러한 타입 계층을 구현할 수 있는 쉽고 편안한 방법을 제공하는 데 있다. 타입 사이의 관계를 고려하지 않은 채 단순히 코드를 재사용하기 위해서 상속을 구현해서는 안된다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p436
>**객체지향 프로그래밍과 객체기반 프로그래밍**
>**객체 기반 프로그래밍(Object-Based Programming)**이란 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식을 가리킨다. 이 정의에 따르면 **객체 지향 프로그래밍(Object-Oriented Programming)** 역시 객체 기반 프로그래밍의 한 종류이다. 객체 지향 프로그래밍은 객체 기반 프로그래밍과 마찬가지로 객체들을 조합하여 애플리케이션을 개발하지만 상속과 다형성을 지원한다는 점에서 객체 기반 프로그래밍과 차별화된다. 간단히 말해서 객체지향 프로그래밍은 상속과 다형성을 지원하지만 객체 기반 프로그래밍은 지원하지 않는다.
>

#### 타입

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p436
>개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미한다. 다시 말해 우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리켜 타입이ㅏㄹ고 부른다. 타입은 사물을 분류하기 위한 틀로 사용된다. 예를 들어, 자바, 루비, 자바스크린트, C를 프로그래밍 언어라고 부를 때 우리는 이것들을 프로그래밍 언어라는 타입으로 분류하고 있는 것이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p437
>어떤 대상이 타입으로 분류될 때 그 대상을 타입의 **인스턴스**라고 부른다. 자바, 루비, 스크립트, C는 프로그래밍 언어의 인스턴스다. 일반적으로 타입의 인스턴스를 **객체**라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p437
>- **심볼(symbol)**: 타입에 이름을 붙인 것이다.
>- **내연(intension)**: 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다. '프로그래밍 언어'의 정의인 '컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합'이 바로 내연에 속한다. 일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성한다.
>- **외연(extension)**: 타입이 속하는 객체들의 집합이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p437
>프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 의미한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p438
> 타입은 다음 두 가지 관점으로 정의할 수 있다.
> - 개념 관점에서 타입은 공통의 특징을 공유하는 대상들의 분류다.
> - 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스를 의미한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p438
>객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.

#### 타입 계층

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p441
>타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 **슈퍼타입(supertype)**이라고 부르고 더 특수한 타입을 **서브타입(subtype)**이라고 부른다. 

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p441
>내연의 관점에서 특수한 타입의 정의는 일반적인 타입의 정의를 좀 더 구체화한 것이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p441
>집합을 의미하는 외연의 관점에서 일반적인 타입의 인스턴스 집한은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋이다. 반대로 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 서브셋이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p442
>슈퍼 타입은 다음과 같은 특징을 가진다.
>- 집합이 다른 집합의 모든 멤버를 포함한다.
>- 타입 정의가 다른 타입보다 더 일반적이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p442
>서브 타입은 다음과 같은 특징을 가진다.
>- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
>- 타입 정의가 다른 타입보다 좀 더 구체적이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p442
>**슈퍼 타입**이란 서브타입이 정의한 퍼블릭 인터페이스를 **일반화**시켜 상대적으로 **범용적이고 넓은 의미**로 정의한 것이다.
>**서브 타입**은 슈퍼타입이 정의한 퍼블릭 인터페이스를 **특수화**시켜 상대적으로 **구체적이고 좁은 의미**로 정의한 것이다.

#### 서브 클래싱과 서브 타이핑

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p444
>마틴 오더스키의 조언에 따르면 두 클래스가 어휘적으로 is-a 관게를 모델링할 경우에만 상속을 사용해야 한다. 어떤 타입 S가 다른 타입 T의 일종이라면 당연히 "타입 S는 타입 T다(S is a T)"라고 말할 수 있어야 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p444~p445
>is-a관계가 생각처럼 직관적이고 명쾌한 것은 아니다. 스콧 마이어스는 "이펙티브 C++"에서 새와 펭귄의 예를 들어 is-a 관계가 직관을 쉽게 배신할 수 있다는 사실을 보여준다.
>- 펭귄은 새다
>- 새는 날 수 있다.
>펭귄은 새지만 새가 날 수 있다는 행동을 정의하는 순간 "펭귄은 새고 날고 있다"가 된다. 이 예는 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 알려준다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p445
>슈퍼 타입과 서브 타입간의 관계는 is-a가 아닌 행동 호환성이 더 중요하다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p445
>행동의 호환 여부를 판단하는 것은 클라이언트의 관점이라는 것이다. 클라이언트가 두 타입을 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다. 클라이언트가 두 타입이 동일하게 행동하지 않을 것이라 기대한다면 두 타입을 타입 계층으로 묶어서는 안된다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p450
>인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 **인터페이스 분리 원칙(Interface Segregation Principle, ISP)**이라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p451
>요점은 자연어에 현혹되지 말고 **요구 사항 속에서 클라이언트가 기대하는 행동에 집중**하라는 것이다. 클래스의 이름 사이에 어떤 연관성이 있다는 사실은 아무런 의미도 없다. 두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입 계층이 아니기 때문에 상속을 사용해서는 안된다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p452
>- **서브 클래싱(subclassing)**: 다른 클래스의 코드를 재사용할 목적으로 상속을 하는 경우를 가르킨다. 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다. 서브 클래싱을 **구현 상속** 또는 **클래스 상속**이라고 부른다.
>- **서브 타이핑(subtyping)**: 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다. 영화 예매 시스템에서 구현한 DiscountPolicy 상속 계층이 서브 타이핑에 해당한다. 서브 타이핑에서는 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. 이 때 부모 클래스는 자식 클래스의 슈퍼 타입이 되고 자식 클래스는 부모 클래스의 서브 타입이 된다. 서브 타이핑을 **인터페이스 상속(interface inheritance)**라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p453
>서브 타이핑 관계가 유지되기 위해서는 서브 타입이 슈퍼 타입이 하는 모든 행동을 동일하게 할 수 있어야 한다. 즉, 어떤 타입이 다른 타입의 서브 타입이 되기 위해서는 **행동 호환성(behavioral sustitution)**을 만족해야 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p453
>행동 호환성을 만족하는 상속 관계는 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것이라는 것을 보장해야 한다. 다시 말해서 자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 **대체 가능성(substitutability)**를 포함한다.

#### 리스코프 치환 법칙

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p453
>리스코프 치환 원칙을 한마디로 정리하면 "서브 타입은 그것의 기반 타입에 대해 대체 가능해야 한다."는 것으로 클라이언트가 "**차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다**"는 것이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p454
>Stack과 Vector는 리스코프 치환 원칙을 위반하는 전형적인 예이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p454
>대부분 사람들은 "정사각형은 직사각형이다"라는 이야기를 당연하게 생각한다. 하지만 정사각형은 직사각형이 아닐 수 있다. 사실 정사각형과 직사각형의 상속 관계는 리스코프 치환 법칙을 위반하는 고전적인 사례 중 하나다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p458
>어떤 모델의 유효성은 클라이언트의 관점에서만 검증 가능하다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p459
>슈퍼 타입과 서브 타입이 클라이언트 입장에서 행동이 호환된다면 두 타입을 is-a로 연결해 문장을 만들어도 어색하지 


## 코멘트