---
tags:
  - 객체지향
  - 객체지향설계
aliases: 
created: 2025-04-17
title: 📚 설계 품질과 트레이드 오프 (오브젝트 - 조용호)
note-type: REF
from: Book
---

## 출처

- $ 오브젝트 - 코드로 이해하는 객체 지향 설계 by 조용호: p.97 ~ p.132

## 요약

『오브젝트 - 코드로 이해하는 객체 지향 설계』(조용호, p.97~p.132)에서는 객체 지향 설계에서 **데이터 중심 설계**와 **책임 중심 설계**의 차이, 그리고 설계 품질을 평가하는 주요 기준인 **응집도**와 **결합도**를 중심으로 설계 트레이드 오프를 다룬다. 데이터 중심 설계는 객체가 저장해야 할 데이터를 먼저 정의하며, 이는 내부 데이터 구조에 초점을 맞춘다. 반면, 책임 중심 설계는 객체의 책임과 협력을 우선시한다. 좋은 설계는 **높은 응집도**(관련된 책임이 하나의 모듈에 모여 변경 시 최소한의 수정만 필요)와 **낮은 결합도**(모듈 간 의존성이 낮아 변경의 파급효과가 적음)를 목표로 한다. 데이터 중심 설계는 데이터 구조에 대한 조기 결정과 협력 문맥의 무시로 인해 변경에 취약하며, 객체 지향 설계는 외부 협력과 인터페이스에 초점을 맞춰야 한다.

## 추가 인용

#### 데이터 중심 시스템

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.99
> 데이터 중심의 설계란 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법이다. **책임 중심의 설계**가 '**책임이 무엇인가**'를 묻는 것으로 시작한다면 **데이터 중심의 설계**는 객체가 내부에 저장해야 하는 '**데이터가 무엇인가**'를 묻는 것으로 시작한다.

#### 설계 트레이드 오프

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.108
>객체 지향이 강력한 이유는 한 곳에서 일어날 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공하기 때문이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.109
>변경될 가능성이 높은 부분을 **구현**이라고 부르고 상대적으로 안정적인 부분을 **인터페이스**라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.110
>**응집도**는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.110
>객체지향의 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 **책임**들을 할당했는지를 나타낸다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.110
>결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다. 

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.110
>객체지향의 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.110
>좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.110
>좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.110
>변경의 관점에서 응집도란 **변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도**로 측정할 수 있다. 하나의 변경을 수용하기 위해 모듈 전체가 변경된다면 응집도가 높은 것이고 모듈의 일부만 변경된다면 응집도가 낮은 것이다. 또한 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮은 것이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.111
>응집도가 높은 설계에서는 하나의 요구사항 변경을 반영하기 위해 오직 하나의 모듈만 수정하면 된다. 반면 응집도가 낮은 설계에서는 하나의 원인에 의해 변경해야 하는 부분이 다수의 모듈에 분산돼 있기 때문에 여러 모듈을 동시에 수정해야 한다.
>![[높은 응집도와 낮은 응집도 (draw).svg]]

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.111
>결합도는 **한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도**로 측정할 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.111
>낮은 결합도를 가진 왼쪽의 설계에서는 모듈 A를 변경했을 때 오직 하나의 모듈만 영향을 받는다는 것을 알 수 있다. 반면 높은 결합도를 가진 오른쪽의 설계에서는 모듈 A를 변경했을 때 4개의 모듈을 동시에 변경해야 한다.
>![[높은 결합도와 낮은 결합도 (draw).svg]]

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.112
>결합도가 높아도 상관 없는 경우도 있다. 일반적으로 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것은 아무런 문제도 되지 않는다. 표준 라이브러리에 포함된 모듈이나 성숙 단계에 접어든 프레임워크에 의존하는 경우가 여기에 속한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.112
>직접 작성한 코드는 낮은 결합도를 유지하려고 노력해야 한다.

#### 데이터 중심 설계의 문제점

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.131
>데이터 중심 설계가 변경에 취약한 이유는 두 가지다.
>- 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
>- 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.


>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.131
>올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.131
>데이터 중심 설계에서 초점은 객체의 외부가 아니라 내부에 향한다. 실행 문맥에 대한 깊이 있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다.


## 코멘트

이 장은 객체 지향 설계의 핵심 원칙인 높은 응집도와 낮은 결합도를 통해 유지보수성과 확장성을 확보하는 방법을 명확히 설명한다. 특히 데이터 중심 설계의 단점—변경에 취약하고 협력 문맥을 간과한다는 점은 현대 소프트웨어 개발에서 여전히 자주 발생하는 문제다. 예를 들어, 데이터베이스 스키마나 DTO 중심으로 설계를 시작하면 초기에는 직관적일 수 있지만, 요구사항 변경 시 코드 수정이 여러 모듈로 확산되는 경우가 많다. 반면, 책임 중심 설계는 객체의 역할과 협력을 먼저 고민함으로써 변경의 파급효과를 줄이고 유연성을 높인다. 이는 특히 마이크로서비스나 모듈화된 시스템 설계에서 중요한데, 각 서비스가 독립적으로 진화해야 하기 때문이다. 다만, 안정적인 표준 라이브러리나 프레임워크에 의존하는 경우 높은 결합도가 큰 문제가 되지 않는다는 점은 실무에서 적절한 트레이드 오프를 판단하는 데 유용한 통찰이다. 이 원칙들을 적용하려면 초기 설계 단계에서 협력 문맥을 충분히 분석하고, 인터페이스를 통해 구현 세부사항을 캡슐화하는 습관이 필요하다.