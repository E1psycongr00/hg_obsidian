---
tags:
  - 객체지향
  - 객체지향설계
aliases: 
created: 2025-04-29
title: 📚 상속과 코드 재사용 (오브젝트 -조용호)
note-type: REF
from: Book
---

## 출처

- $ 오브젝트 - 코드로 이해하는 객체 지향 설계 by 조용호: p.308 ~ p.345

## 요약

## 추가 인용

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p308
>전통적인 패러다임에서 코드를 재사용하는 방법은 코드를 복사한 후 수정하는 것이다. 객체지향은 조금 다른 방법을 취한다. 객체지향에서 코드를 재사용하기 위해 '새로운' 코드를 추가한다. 객체지향에서 코드는 일반적으로 클래스 안에 작성되기 때문에 객체지향에서 클래스를 재사용하는 전통적인 방법은 새로운 클래스를 추가하는 것이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p308
>재사용 관점에서 상속이란 클래스 안ㅇ 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법이다.

#### 상속과 중복된 코드

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p309
>중복 코드가 가지는 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것이다. 우선 어떤 코드가 중복인지 찾아야 한다. 

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p309
>중복 여부를 판단하는 기준은 변경이다. 요구사항이 변경되었을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p309
>앤드류 헌트와 데이비드 토마스의 말을 인용하자면 프로그래머들은 **DRY 원칙**을 따라야 한다. DRY는 '반복하지 마라' 라는 뜻의 **Don't Repeat Yourself**의 첫 글자를 모아 만든 용어로 간단히 말해 동일한 지식을 중복하지 말라는 것이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p310
>DRY 원칙
>모든 지식은 시스템 내에서 단일하고, 애매하지 안고, 정말로 믿을 만한 표현 양식을 가져야 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p310
>DRY 원칙은 한 번, 단 한번 원칙 또는 단일 지점 제어 원칙이라고도 부른다.


>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p322
>자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출한 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.


>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p322
>상속 관계로 연결된 자식 클래스가 부모 클래스의 변경ㅇ 취약해지는 현상을 가리켜 취약한 기반 클래스 문제라고 부른다. 취약한 기반 클래스 문제는 코드 재사용을 목적으로 상속을 사용할 때 발생하는 가장 대표적인 문제다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p323
> 상속은 자식 클래스와 부모 클래스의 결합도를 높인다. 이 강한 결합도로 인해 자식 클래스는 부모 클래스의 불필요한 세부사항에 엮이게 된다. 부모 클래스의 작은 변경에도 자식 클래스는 컴파일 오류와 실행 에러라는 고통에 시달려야 한다.


>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p323
>구현을 상속한 경우 파생 클래스는 기반 클래스에 강하게 결합되며, 둘 사이의 밀접한 연결은 바람직하지 않다. 설계자는 이런 설계에 대해 '취약한 기반 클래스 문제' 라는 명칭을 붙였다. 겉으로 보기에는 안전한 방식으로 기반 클래스를 수정한 것처럼 보이더라도 이 새로운 행동이 파생 클래스에게 상속될 경우 파생 클래스의 잘못된 동작을 초래할 수 있기 때문에 기반 클래스는 "취약하다". 

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p323
>객체를 사용하는 이유는 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화할 수 있기 때문이다. 캡슐화는 변경에 의한 파급효과를 제어할 수 있기 때문에 가치가 있다. 객체는 변경될지도 모르는 불안정한 요소를 캡슐화함으로써 파급효과를 걱정하지 않고도 자유롭게 내부를 변경할 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p324
>자바의 초기 버전에서 상속을 잘못 사용한 사례는 java.util.Properties와 java.util.Stack이다. 두 클래스의 공통점은 부모 클래스에서 상속받은 메서드를 사용할 경우 자식 클래스의 규칙이 위반될 수 있다는 것이다. 먼저 Stack을 살펴보자.
>
>Stack은 FIFO을 구현한 클래스다. Vector는 임의의 위치에서 요소를 추출하고 삽입할 수 있는 리스트 자료 구조의 구현체로써 java.util.List의 초기 버전이라고 할 수 있다. 자바의 초기 컬렉션 프레임워크 개발자들은 요소의 추가, 삭제 오퍼레이션을 제공하는 Vector를 재사용하기 위해 Stack을 Vector의 자식 클래스로 구현했다.
>
>![[Pasted image 20250429180353.png]]
>
>안타깝게도 Stack이 Vector를 상속받았기 때문에 Stack의 퍼블릭 인터페이스에 Vector의 퍼블릭 인터페이스가 합쳐진다. 따라서 Stack에게 상속된 Vector의 퍼블릭 인터페이스를 이용하면 임의의 위치에서 요소를 추가하거나 삭제할 수 있다. 따라서 맨 마지막 위치에서만 요소를 추가하거나 제거할 수 있도록 허용하는 Stack의 규칙을 쉽게 위반할 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p325
>인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 만들어야 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p326
>상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p328
>자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p329
>클래스에서는 메서드 오버라이딩으로 인한 파급 효과를 분명하게 문서화해야 한다. 달리 말해 오버라이딩 가능한 메서드들의 자체 사용, 즉, 그 메서드들이 같은 클래스의 다른 메서드를 호출하는지에 대해 반드시 문서화해야 한다. 이와는 반대로, public이나 protected 메서드 및 생성자가 어떤 오버라이딩 가능한 메서드를 호출하는지, 어떤 순서로 하는지, 호출한 결과가 다음 처리에 어떤 영향을 주는지에 대해서도 반드시 문서화해야 한다. 더 일반적으로 말하면 오버라이딩 가능한 메서드를 호출할 수 있는 어떤 상황에 대해서도 문서화해야 한다는 것이다.




## 코멘트