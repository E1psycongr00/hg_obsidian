---
tags:
  - 객체지향
  - 객체지향설계
aliases: 
created: 2025-05-01
title: 📚 합성과 유연한 설계 (오브젝트 - 조용호)
note-type: REF
from: Book
---

## 출처

- $ 오브젝트 - 코드로 이해하는 객체 지향 설계 by 조용호: p.346 ~ p.388

## 요약



## 추가 인용

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p346
>상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일 타임에 해결되지만, 합성에서 두 객체의 의존성은 런타임에 해결된다. 상속 관계는 **is-a** 관계이고, 합성은 **has-a** 관계라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p346
>상속을 제대로 활용하기 위해서는 부모 클래스의 내부 구현에 대해 상세히 알아야 하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아질 수 밖에 없다. 결과적으로 상속은 코드 재사용할 수 있는 쉽고 간단한 방법일지는 몰라도 우아한 방법이라 볼 수 없다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p346
>합성은 구현에 의존하지 않는다는 점에서 상속과 다르다. 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다. 따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 변경에 더 안정적인 코드를 얻을 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p347
>상속 관계는 클래스 사이의 정적인 관계인데 비해 합성은 동적인 관계이다. 이 차이점은 생각보다 중요한데 상속 관계는 변경이 불가능하지만, 합성 광계는 실행 시점에서 동적으로 변경할 수 있기 때문이다. 따라서 상속 대신 합성을 이용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p347
>상속은 부모 클래스 안에 구현된 코드 자체를 재사용한다. 하지만 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다. 따라서 상속 대신 합성을 사용하면 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경할 수 있다. 다시 말해서 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p347
>객체지향 시스템에서 기능을 재사용할 수 있는 가장 대표적인 기법은 클래스 상속과 객체 합성이다. 클래스 상속은 다른 클래스를 이용해서 한 클래스의 구현을 정의하는 것이다. 서브 클래싱에 의한 재사용을 화이트박스 재사용이라고 부른다. 화이트박스라는 말은 가시성 떄문에 나온 말이다. 상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되기 때문에 화이트박스인 셈이다. 
>
>객체 합성은 클래스 상속의 대안ㄴ이다. 새로운 기능을 위해 객체를 합성한다. 객체를 합성하려면 합성할 객체들으 ㅣ인터페이스를 명확하게 정의해야만 한다. 이런 스타일의재사용을 블랙박스 재사용이라고 하는데, 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문이다.

#### 상속으로 인한 조합의 폭발적인 증가

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p353
>상속으로 인한 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 늘어나는 경향이 있다. 가장 일반적인 상황은 작은 기능들을 조합해서 더 큰 기능을 수행하는 객체들 만들어야 하는 경우다. 일반적으로 다음과 같은 두 가지 문제점이 발생한다.
>- 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
>- 단일 상속만 지언하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p360
>**추상 메서드와 훅 메서드**
>개방-폐쇄 원칙을 만족하는 설계를 만들 수 있는 한 가지 방법은 부모 클래스에서 새로운 추상 메서드를 추가하고 부모 클래스의 다른 메서드 안에서 호출하는 것이다. 자식 클래스에서는 추상 클래스를 오버라이딩하고 자신만의 로직을 구현해서 부모 클래스에서 정의한 플로우에 개입할 수 있게 된다. 처음에 Phone 클래스에서 추상 메서드인 calculateCallFee와 afterCalculated를 선언하고 자식 클래스에서 두 메서드를 오버라이딩한 방식이 이 방식을 응용한 것이다.
>
>추상 메서드의 단점은 상속 계층에 속하는 모든 자식 클래스가 추상 메서드를 오버라이딩해야 하는 것이다. 대부분의 자식 클래스가 추상 메서드를 동일한 방식으로 구현한다면 상속 계층 전반에 걸쳐 중복 코드가 존재하게 될 것이다. 해결 방법은 메서드에 기본 구현을 제공하는 것이다. 이처럼 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드를 훅 메서드라고 부른다. 예제에서 기본 구현을 가지도록 수정된 afterCalculated 메서드가 바로 훅 메서드이다.



## 코멘트