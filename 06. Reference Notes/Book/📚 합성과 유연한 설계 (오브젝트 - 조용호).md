---
tags:
  - 객체지향
  - 객체지향설계
aliases: 
created: 2025-05-01
title: 📚 합성과 유연한 설계 (오브젝트 - 조용호)
note-type: REF
from: Book
---

## 출처

- $ 오브젝트 - 코드로 이해하는 객체 지향 설계 by 조용호: p.346 ~ p.388

## 요약

**합성과 유연한 설계**는 조용호의 _오브젝트_ 책에서 객체지향 설계의 핵심 개념인 상속과 합성을 비교하며, 합성이 상속보다 유연하고 변경에 안정적인 설계를 가능하게 한다고 설명한다. 주요 내용은 다음과 같다:

1. **상속 vs 합성**:
    - **상속**: 부모와 자식 클래스 간 정적(is-a) 관계로, 컴파일 타임에 의존성이 고정된다. 부모 클래스 구현에 강하게 결합되어 코드 재사용은 쉽지만 유연성이 떨어지고 변경이 어렵다. 이를 **화이트박스 재사용**이라 부른다.
    - **합성**: 객체 간 동적(has-a) 관계로, 런타임에 의존성을 변경할 수 있다. 객체의 퍼블릭 인터페이스에 의존하므로 내부 구현 변경에 영향을 덜 받아 안정적이다. 이를 **블랙박스 재사용**이라 부른다.
2. **상속의 문제점**:
    - 높은 결합도로 인해 코드 수정이 복잡해진다.
    - **클래스 폭발 문제**: 작은 기능을 추가하기 위해 많은 클래스를 생성하거나 수정해야 하며, 단일 상속 언어에서는 중복 코드가 늘어날 수 있다.
    - 추상 메서드와 훅 메서드를 사용해 개방-폐쇄 원칙을 지키려 해도, 자식 클래스가 추상 메서드를 모두 구현해야 하거나 중복 코드가 발생할 수 있다.
3. **합성의 장점**:
    - 런타임에 객체 의존성을 동적으로 변경 가능.
    - 컴파일타임과 런타임 의존성을 분리해 유연성을 높인다.
    - 클래스 폭발 문제를 해결하며, 조합을 개별 클래스로 나누고 실행 시점에 조립해 설계의 유연성을 확보한다.
4. **핵심 메시지**:
    - 상속은 구현 재사용에, 합성은 인터페이스 재사용에 초점을 맞춘다.
    - 합성은 낮은 결합도와 높은 유연성을 제공하므로, 상속의 남용을 피하고 합성을 우선 고려해야 한다.

## 추가 인용

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p346
>상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일 타임에 해결되지만, 합성에서 두 객체의 의존성은 런타임에 해결된다. 상속 관계는 **is-a** 관계이고, 합성은 **has-a** 관계라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p346
>상속을 제대로 활용하기 위해서는 부모 클래스의 내부 구현에 대해 상세히 알아야 하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아질 수 밖에 없다. 결과적으로 상속은 코드 재사용할 수 있는 쉽고 간단한 방법일지는 몰라도 우아한 방법이라 볼 수 없다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p346
>합성은 구현에 의존하지 않는다는 점에서 상속과 다르다. 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다. 따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 변경에 더 안정적인 코드를 얻을 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p347
>상속 관계는 클래스 사이의 정적인 관계인데 비해 합성은 동적인 관계이다. 이 차이점은 생각보다 중요한데 상속 관계는 변경이 불가능하지만, 합성 광계는 실행 시점에서 동적으로 변경할 수 있기 때문이다. 따라서 상속 대신 합성을 이용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p347
>상속은 부모 클래스 안에 구현된 코드 자체를 재사용한다. 하지만 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다. 따라서 상속 대신 합성을 사용하면 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경할 수 있다. 다시 말해서 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p347
>객체지향 시스템에서 기능을 재사용할 수 있는 가장 대표적인 기법은 클래스 상속과 객체 합성이다. 클래스 상속은 다른 클래스를 이용해서 한 클래스의 구현을 정의하는 것이다. 서브 클래싱에 의한 재사용을 화이트박스 재사용이라고 부른다. 화이트박스라는 말은 가시성 떄문에 나온 말이다. 상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되기 때문에 화이트박스인 셈이다. 
>
>객체 합성은 클래스 상속의 대안ㄴ이다. 새로운 기능을 위해 객체를 합성한다. 객체를 합성하려면 합성할 객체들으 ㅣ인터페이스를 명확하게 정의해야만 한다. 이런 스타일의재사용을 블랙박스 재사용이라고 하는데, 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문이다.

#### 상속으로 인한 조합의 폭발적인 증가

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p353
>상속으로 인한 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 늘어나는 경향이 있다. 가장 일반적인 상황은 작은 기능들을 조합해서 더 큰 기능을 수행하는 객체들 만들어야 하는 경우다. 일반적으로 다음과 같은 두 가지 문제점이 발생한다.
>- 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
>- 단일 상속만 지언하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p360
>**추상 메서드와 훅 메서드**
>개방-폐쇄 원칙을 만족하는 설계를 만들 수 있는 한 가지 방법은 부모 클래스에서 새로운 추상 메서드를 추가하고 부모 클래스의 다른 메서드 안에서 호출하는 것이다. 자식 클래스에서는 추상 클래스를 오버라이딩하고 자신만의 로직을 구현해서 부모 클래스에서 정의한 플로우에 개입할 수 있게 된다. 처음에 Phone 클래스에서 추상 메서드인 calculateCallFee와 afterCalculated를 선언하고 자식 클래스에서 두 메서드를 오버라이딩한 방식이 이 방식을 응용한 것이다.
>
>추상 메서드의 단점은 상속 계층에 속하는 모든 자식 클래스가 추상 메서드를 오버라이딩해야 하는 것이다. 대부분의 자식 클래스가 추상 메서드를 동일한 방식으로 구현한다면 상속 계층 전반에 걸쳐 중복 코드가 존재하게 될 것이다. 해결 방법은 메서드에 기본 구현을 제공하는 것이다. 이처럼 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드를 **훅 메서드**라고 부른다. 예제에서 기본 구현을 가지도록 수정된 afterCalculated 메서드가 바로 훅 메서드이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p367
>상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우를 가리켜 **클래스 폭발 문제** 또는 **조합의 폭발 문제**라고 부른다. 클래스 폭발의 문제는 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계 떄문에 발생하는 문제다.

#### 합성 관계로 변경하기

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p368
>상속과 달리 합성 관계는 런타임에 동적으로 변경할 수 있다. 합성을 사용하면 컴파일타임 의존성과 런타임 의존성을 다르게 만들 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p368
>클래스 폭발 문제를 해결하기 위해 합성을 사용하는 이유는 런타임에 객체 사의의 의존성을 자유롭게 변경할 수 있기 때문이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체지향 설계, p368
>상속이 조합의 결과를 개별 클래스 안으로 밀어 넣는 방법이라면 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 후 실행 시점에 인스턴스를 조립하는 방법을 사용하는 것이라고 할 수 있다. 컴파일 의존성에 속박되지 않고 다양한 방식의 런타임 의존성을 구성할 수 있다는 것이 합성이 제공하는 가장 커다란 장점이다.




## 코멘트

이 장은 객체지향 설계에서 상속과 합성의 본질적 차이를 명확히 짚으며, 합성이 현대 소프트웨어 설계에서 왜 더 선호되는지를 설득력 있게 설명한다. 상속은 직관적이고 초기 개발에서는 편리하지만, 장기적으로 클래스 계층이 복잡해지고 유지보수가 어려워지는 문제를 야기한다. 특히 **클래스 폭발 문제**는 상속의 정적 특성과 높은 결합도가 낳는 전형적인 부작용으로, 실무에서 자주 마주치는 설계의 함정이다.

반면, 합성은 런타임 유연성과 인터페이스 기반 설계를 통해 변경에 강한 코드를 만든다. 이는 특히 마이크로서비스나 모듈화된 시스템처럼 동적이고 확장 가능한 아키텍처가 중요한 환경에서 빛을 발한다. 예를 들어, 합성을 활용한 **전략 패턴**이나 **데코레이터 패턴**은 런타임에 동작을 조합해 복잡한 기능을 간결하게 구현할 수 있는 좋은 사례다.

다만, 합성이 상속보다 항상 우월한 것은 아니다. 상속은 간단한 계층 구조나 명확한 is-a 관계에서 여전히 유효하며, 합성은 설계 초기의 복잡도를 약간 높일 수 있다. 따라서 두 기법의 tradeoff를 이해하고, 프로젝트의 요구사항과 변경 가능성을 고려해 적절히 선택하는 것이 중요하다. 이 장은 합성을 통해 유연한 설계를 추구하라는 강력한 메시지를 전달하며, 객체지향 설계의 핵심 원칙인 **낮은 결합도와 높은 응집도**를 다시금 상기시킨다.