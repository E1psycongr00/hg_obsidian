---
tags:
  - 객체지향
  - 객체지향설계
aliases: 
created: 2025-04-15
title: 📚 객체지향 프로그래밍 (오브젝트 - 조용호)
note-type: REF
from: Book
---

## 출처

- $ 오브젝트 - 코드로 이해하는 객체 지향 설계 by 조용호: p.37 ~ p.72

## 요약

『오브젝트 - 코드로 이해하는 객체지향 설계』(조용호, p.37~p.72)에서는 객체지향 프로그래밍의 핵심 개념을 다룬다. 주요 내용은 다음과 같다:

- **객체 중심 설계**: 클래스가 아닌 객체에 초점을 맞춰야 하며, 객체는 협력하는 공동체의 일원으로 간주된다. 어떤 객체가 필요한지, 그 객체의 상태와 행동이 무엇인지 먼저 고민해야 한다.
- **도메인**: 사용자가 프로그램을 사용하는 문제를 해결하는 분야를 의미한다.
- **캡슐화와 자율성**: 객체는 퍼블릭 인터페이스와 구현으로 나뉘며, 명확한 경계는 객체의 자율성과 구현의 자유를 보장한다.
- **협력과 메시지**: 객체는 메시지 전송을 통해 상호작용하며, 메시지를 처리하는 방법은 객체가 자율적으로 결정한다(메서드). 이를 지연 바인딩(동적 바인딩)으로 구현한다.
- **상속과 다형성**: 상속은 구현 상속(서브클래싱)과 인터페이스 상속(서브타이핑)으로 나뉜다. 다형성은 동일한 메시지에 대해 객체 타입에 따라 다르게 응답하는 능력이다. 하지만 코드 의존성과 실행 시점 의존성의 차이는 유연성을 높이는 동시에 이해를 어렵게 만든다.
- **추상화**: 상위 정책을 간단히 표현해 도메인의 핵심 개념을 명확히 한다.
- **상속의 단점과 합성**: 상속은 캡슐화를 위반하고 설계를 경직되게 만들 수 있다. 반면, 합성은 메시지 기반으로 코드를 재사용해 캡슐화를 유지하고 유연성을 높인다.

## 추가 인용

#### 협력 객체 클래스

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.40
> 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.41
> **어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.** 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.41
> 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.

#### 도메인

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.41
> 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 **도메인**이라고 부른다.

#### 자율적인 객체

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.43
> 클래스의 내부와 외부를 구분해야 하는 이유는 뭘까? 그 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다. 그리고 더 중요한 이유로 프로그래머에게 구현의 자유를 제공하기 때문이다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.44
> 캡슐화와 접근 제어는 객체를 두 부분으로 나눈다. 하나는 외부에서 접근 가능한 부분으로 이를 **퍼블릭 인터페이스**라고 부른다. 다른 하나는 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 **구현**이라고 부른다.

#### 협력에 대한 짧은 이야기


> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.49
> 객체가 다른 객체와 상호작용할 수 있는 방법은 **메시지를 전송**하는 것뿐이다. 다른 객체에게 요청이 도착할 때 해당 객체가 **메시지를 수신**했다고 이야기한다. 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다. 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드**(method)라고 부른다.

#### 상속과 다형성

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.59
> 한 가지 간과해서는 안 되는 사실은 **코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다는 것이다**. 코드를 이해하기 위해서는 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문이다. 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다. 이와 같은 의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 잘 보여준다.


> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.59
> 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억하라. 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다는 사실도 기억하라.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.59
> 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 한다. 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.63
> 다형성이란 동일한 메시지(인터페이스)를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.63
> 메시지와 메서드를 실행 시점에 바인딩한다. 이를 **지연 바인딩**(lazy binding) 또는 **동적 바인딩**(dynamic binding)이라고 부른다. 이에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 **초기 바인딩**(early binding) 또는 **정적 바인딩**(static binding)이라고 한다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.64
> 상속을 **구현 상속**과 **인터페이스 상속**으로 분류할 수 있다. 흔히 구현 상속을 **서브 클래싱**이라고 부르고 인터페이스 상속을 **서브타이핑**이라고 부른다. 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 구현 상속이라고 부른다. 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 **인터페이스 상속**이라고 부른다.

#### 추상화와 유연성

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.66
> 추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다. 추상화의 이런 특징은 세부사항에 억눌리지 않고 상위 개념만으로 도메인의 중요한 개념을 설명할 수가 있다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.66
> 추상화를 이용해 상위 정첵을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다.

#### 상속

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.70
> 상속은 객체지향에서 코드를 재사용하기 위해 널리 사용하는 기법이다. 하지만 두가지 관전에서 안 좋은 영향을 미친다. 하나는 상속이 캡슐화를 위반한다는 것이고, 다른 하나는 서계를 유연하지 못하게 만든하는 것이다.

#### 합성

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.72
> 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 **합성**이라 부른다.
> 

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.72
> 합성은 상속이 가지는 2가지를 모두 해결할 수 있다. 인터페이스에 정의된 메시지를 통해서만 사용가능하기 때문에 구현을 효과적으로 캡슐화할 수 있고, 의존하는 인스턴스를 교체하는  것이 비교적 쉽기 때문에 설계를 유연하게 만든다.


## 코멘트

이 책의 해당 챕터는 객체지향 설계의 본질을 깊이 탐구하며, 객체 중심 사고의 중요성을 강조한다. 특히 "클래스가 아닌 객체에 초점을 맞추라"는 메시지는 설계 초보자들이 자주 간과하는 부분을 명확히 짚어준다. 객체를 독립적인 존재가 아닌 협력의 일원으로 보는 관점은, 실제 소프트웨어가 동작하는 환경(다양한 객체 간 상호작용)을 반영한 현실적인 접근이다.

캡슐화와 자율성에 대한 설명은 객체지향의 핵심 원칙을 이해하는 데 큰 도움을 준다. 퍼블릭 인터페이스와 구현의 분리는 유지보수성과 확장성을 높이는 설계의 기본이 된다. 또한, 상속과 합성의 비교는 흥미롭다. 상속이 편리해 보이지만 캡슐화 위반과 경직성 문제를 초래할 수 있다는 점은, 합성의 유연성과 견고함을 선택해야 할 이유를 설득력 있게 제시한다.

다만, 코드 의존성과 실행 시점 의존성의 트레이드오프(유연성 vs 가독성)는 설계 시 항상 고민해야 할 지점이다. 이 책은 단순히 정답을 주기보다는, 개발자가 상황에 맞게 균형을 찾도록 유도한다. 추상화를 통해 복잡한 도메인을 단순화하는 방법도 실무에서 매우 유용하다고 느껴진다.

결론적으로, 이 부분은 객체지향 설계의 철학과 실천적 기법을 균형 있게 다루며, 초보자부터 숙련자까지 설계에 대한 통찰을 얻을 수 있는 내용으로 가득하다. 합성을 활용한 유연한 설계와 객체 간 협력 중심의 사고를 실무에 적용해보고 싶다는 생각이 든다.