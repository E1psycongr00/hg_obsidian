---
tags:
  - 객체지향
  - 객체지향설계
aliases: 
created: 2025-04-15
title: 📚 객체지향 프로그래밍 (오브젝트 - 조용호)
note-type: REF
from: Book
---

## 출처

- $ 오브젝트 - 코드로 이해하는 객체 지향 설계 by 조용호: p.37 ~ p.72

## 요약

## 추가 인용

#### 협력 객체 클래스

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.40
> 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.41
> **어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.** 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.41
> 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.

#### 도메인

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.41
> 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 **도메인**이라고 부른다.

#### 자율적인 객체

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.43
> 클래스의 내부와 외부를 구분해야 하는 이유는 뭘까? 그 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다. 그리고 더 중요한 이유로 프로그래머에게 구현의 자유를 제공하기 때문이다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.44
> 캡슐화와 접근 제어는 객체를 두 부분으로 나눈다. 하나는 외부에서 접근 가능한 부분으로 이를 **퍼블릭 인터페이스**라고 부른다. 다른 하나는 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 **구현**이라고 부른다.

#### 협력에 대한 짧은 이야기


> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.49
> 객체가 다른 객체와 상호작용할 수 있는 방법은 **메시지를 전송**하는 것뿐이다. 다른 객체에게 요청이 도착할 때 해당 객체가 **메시지를 수신**했다고 이야기한다. 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다. 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드**(method)라고 부른다.

#### 상속과 다형성

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.59
> 한 가지 간과해서는 안 되는 사실은 **코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다는 것이다**. 코드를 이해하기 위해서는 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문이다. 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다. 이와 같은 의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 잘 보여준다.


> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.59
> 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억하라. 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다는 사실도 기억하라.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.59
> 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 한다. 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.63
> 다형성이란 동일한 메시지(인터페이스)를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.63
> 메시지와 메서드를 실행 시점에 바인딩한다. 이를 **지연 바인딩**(lazy binding) 또는 **동적 바인딩**(dynamic binding)이라고 부른다. 이에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 **초기 바인딩**(early binding) 또는 **정적 바인딩**(static binding)이라고 한다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.64
> 상속을 **구현 상속**과 **인터페이스 상속**으로 분류할 수 있다. 흔히 구현 상속을 **서브 클래싱**이라고 부르고 인터페이스 상속을 **서브타이핑**이라고 부른다. 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 구현 상속이라고 부른다. 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 **인터페이스 상속**이라고 부른다.

#### 추상화와 유연성

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.66
> 추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다. 추상화의 이런 특징은 세부사항에 억눌리지 않고 상위 개념만으로 도메인의 중요한 개념을 설명할 수가 있다.

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.66
> 추상화를 이용해 상위 정첵을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다.

#### 상속

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.70
> 상속은 객체지향에서 코드를 재사용하기 위해 널리 사용하는 기법이다. 하지만 두가지 관전에서 안 좋은 영향을 미친다. 하나는 상속이 캡슐화를 위반한다는 것이고, 다른 하나는 서계를 유연하지 못하게 만든하는 것이다.

#### 합성

> [!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.72
> 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 **합성**이라 부른다.
> 

## 코멘트