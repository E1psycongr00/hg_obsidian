---
tags:
  - 객체지향
  - 객체지향설계
aliases: 
created: 2025-04-25
title: 📚 유연한 설계 (오브젝트 - 조용호)
note-type: REF
from: Book
---

## 출처

- $ 오브젝트 - 코드로 이해하는 객체 지향 설계 by 조용호: p.282 ~ p.307

## 요약

## 추가 인용

#### 개방-폐쇄 원칙

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.282
>- **확장에 대해 열려 있다**.: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션 기능을 확장할 수 있어야 한다.
>- **수정에 대해 닫혀 있다**: 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있어야 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.284
>개방-폐쇄 원릭의 핵심은 '추상화'에 의존하는 것이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.284
>추상화란 핵심적인 부분만 남기고 불필요한 부분을 생략함으로써 복잡성을 극복하는 기법이다. 추상화 과정을 거치면서 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다. 추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워 넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.286
>변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않는 것에 대한 이해가 필요하고 이를 추상화의 목적으로 삼아야 한다.

#### 생성 사용 분리

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.287
>객체 생성에 대한 지식은 과도한 결합도를 초래하는 경향이 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.288
>유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.한마디로 말해서 **객체의 사용과 생성을 분리**해야 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.288
>소프트웨어 시스템은 시작 단계와 실행 단계를 분리해야 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.289
>객체 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.291
>크레이그 라만은 시스템을 객체로 분해하는 데는 두 가지 방법이 존재한다. 하나는 **표현적 분해**(representational decomposition) 그리고 다른 하나는 **행위적 분해**(behavioral decomposition)이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.291
>표현적 분해는 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것이다. 표현적 분해는 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 시스템 사이의 표현적 차이를 최소화하는 것을 목적으로 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.291
>종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 방법만으로는 부족하다. 실제로 동작하는 애플리케이션은 데이터베이스 접근을 위한 객체와 같이 도메인 개념을 초월하는 기계적인 개념이 필요할 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.291
>크레이그 라만은 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 **PURE FABRICATION**(순수한 가공물)이라 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.291
>어떤 행동을 추가하려고 하는데 그 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면 PURE FABRICATION을 추가하고 이 객체에게 책임을 위임하라.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.292
>설계자로써 우리의 역할은 도메인 추상화를 기반으로 애플리케이션 로직을 설계하는 동시에 품질의 측면에서 균형을 맞추는 데 필요한 객체를 창조하는 것이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.292
>도메인의 본질적인 개념을 표현하는 추상화를 이용해 애플리케이션 구축을 시작하라. 만약 도메인 개념이 만족스럽지 못하다면 주저하지 말고 인공적은 객체를 창조하라.

#### 의존성 주입

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.293
>사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 **의존성 주입**이라고 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.293
>- **생성자 주입**: 객체를 생성하는 시점에 생성자를 통한 의존성 해결
>- **setter 주입**: 객체 생성 후 setter 메서드를 통한 의존성 해결
>- **메서드 주입**: 메서드 실행 시 인자를 이용한 의존성 해결

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.295
>```java
>public interface DiscountPolicyInjectable {
>	public void inject(DiscountPolicy discountPolicy);
>}
>```
>DiscountPolicy를 주입받는 객체는 이 인터페이스를 구현해야 한다.
>
>```java
>public class Movie implements DiscountPolicyInjectable {
>	private DiscountPolicy discountPolicy;
>	
>	@Override
>	public void inject(DiscountPolicy discountPolicy) {
>		this.discountPolicy = discountPolicy;
>	}
>}
>```
>인터페이스 주입은 자바 진영에서 만들어진 몇몇프레임워크에서 의존성 대상을 좀 더 명시적으로 정의하고 편리하게 관리하기 위해 도입된 방법이다.






## 코멘트