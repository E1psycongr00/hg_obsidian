---
tags:
  - 객체지향
  - 객체지향설계
aliases: 
created: 2025-04-21
title: 📚 의존성 관리하기 (오브젝트 -조용호)
note-type: REF
from: Book
---

## 출처

- $ 오브젝트 - 코드로 이해하는 객체 지향 설계 by 조용호: p.253 ~ p.281

## 요약

## 추가 인용

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.253
>협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션 수정을 어렵게 만든다. 객체지향의 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 불필요한 의존성은 제거하는 데 있다.

#### 의존성 이해하기

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.254
>- **실행 시점**: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
>- **구현 시점**: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.254
>어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.254
>의존성은 항상 단방향이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.260
>어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.260
>컴파일 타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.260
>클래스가 특정 문맥에 강하게 결합할수록 다른 문맥에서 사용하기 어려워진다. 클래스가 사용될 특정한 문맥에 대해 최소한 가정만으로 이루어져 있다면 다른 문맥에서 재사용하기 더 수월해진다. 이를 **컨텍스트 독립성**이라고 한다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.261
>컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라 부른다. 의존성 해결 방식은 크게 3가지로 사용된다.
>- 객체를 생성하는 시점에 생성자를 통한 의존성 해결
>- 객체 생성후 setter 메서드를 통해 의존성 해결
>- 메서드 실행 시 인자를 사용해 의존성 해결

#### 유연한 설계

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.265
>바람직한 의존성은 재사용성과 관련이 있다. 어떤 의존성이 다양한 환경에서 클래스를 재사용하는 것을 제한하고 있다면 그 의존성은 바람직하지 못한 의존성이다. 어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직하다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.266
>바람직한 의존성과 바람직하지 못한 의존성을 좀 더 세련된 말로 결합도라고 한다. 바람직한 의존성일 때 느슨한 결합도(loose coupling)이라 하며, 약한 결합도(weak coupling)를 가진다고 말한다. 반대로 바람직하지 못한 결하보를 가진 경우 단단한 결합도(tight coupling) 또는 강한 결합도(strong coupling)이라 한다.



## 코멘트