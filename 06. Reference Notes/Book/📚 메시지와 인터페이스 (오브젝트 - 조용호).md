---
tags:
  - 객체지향
  - 객체지향설계
aliases: 
created: 2025-04-18
title: 📚 메시지와 인터페이스 (오브젝트 - 조용호)
note-type: REF
from: Book
---

## 출처

- $ 오브젝트 - 코드로 이해하는 객체 지향 설계 by 조용호: p.175 ~ p.215

## 요약


## 추가 인용

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.175
>클래스라는 구현 도구에 너무 지나치게 집착하면 유연하지 못한 설계에 이를 확률이 높아진다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.175
>훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 한다. 좀 더 정확하게 말해서 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다.

#### 협력과 메시지

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.176
>두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포는 **클라이언트-서버 모델**이다. 협력 안에서 메시지를 전송하는 객체를 **클라이언트**, 메시지를 수신하는 객체를 **서버**라고 부른다. **협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용**이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.177
>**메시지**는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다. 한 객체가 다른 객체에게 도움을 요청하는 것을 **메시지 전송** 또는 **메시지 패싱**이라고 부른다. 이때 메시지를 전송하는 객체를 **메시지 전송자**라고 부르고 메시지를 수신하는 객체를 **메시지 수신자**라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.177
>메시지는 **오퍼레이션명**(operation name)과 **인자**(argument)로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.178
>메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.179
>외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다. 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 **퍼블릭 인터페이스**라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.179
>오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다. 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.179
>UML은 공식적으로 오퍼레이션을 다음과 같이 정의한다.
>오퍼레이션이란 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.180
>![[메시지, 오퍼레이션, 메서드 관계 (draw).svg]]

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.180
>오퍼레이션의 이름과 파라미터 목록을 합쳐 **시그니처**(signature)라고 부른다. 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다.

#### 인터페이스와 설계 품질

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.183
>디미터 법칙을 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.190
>어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 **의도를 드러내는 선택자**(Intention Revealing Selector)라고 부른다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.190
>... 방법이 아닌 의도를표현하는 추상적인 인터페이스 뒤로 모든 까다로운 메커니즘을 캡슐화해야 한다. 도메인의 퍼블릭 인터페이스에서는 관계와 규칙을 시행하는 방법이 아닌 이벤트와 규칙 그 자체만 명시한다.
>... 방정식을 푸는 방법을 제시하지 말고 이를 공식으로 표현하라. 문제를 내라. 하지만 그 문제를 푸는 방법을 표현해서는 안된다.

#### 명령 - 쿼리 분리 원칙

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.202
>어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 **루틴**(routine)이라고 부른다. 루틴은 다시 **프로시저**(procedure)와 **함수**(function)로 구분할 수 있다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.202
>- 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
>- 함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.

>[!cite] 오브젝트 - 코드로 이해하는 객체 지향 설계, p.202
>- 객체의 상태를 반환하는 명령은 반환값을 가질 수 없다.
>- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.



## 코멘트